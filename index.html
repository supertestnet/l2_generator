<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <script src="https://supertestnet.github.io/hedgehog-advanced/noble-secp256k1.js"></script>
        <script src="https://supertestnet.github.io/hedgehog-advanced/tapscript.js"></script>
        <script src="https://supertestnet.github.io/hedgehog-advanced/rmd160.js"></script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/bolt11.js"></script>
        <script src="https://supertestnet.github.io/nwcjs/nwcjs.js"></script>
        <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
        <script src="https://bundle.run/bech32@2.0.0"></script>
        <script>
            delete sessionStorage[ "txid_and_hash_for_confirming_papa_swap" ];
            var loop_delay = 20;
            var hedgehog = {
                network: "testnet",
                state: {},
                keypairs: {},
                state_obj: {
                    alices_privkey: null,
                    bobs_privkey: null,
                    alices_pubkey: null,
                    bobs_pubkey: null,
                    multisig_script: null,
                    multisig_tree: null,
                    multisig_utxo_info: {},
                    i_was_last_to_send: false,
                    alice_can_revoke: [],
                    bob_can_revoke: [],
                    balances: [],
                    balances_before_most_recent_send: [],
                    balances_before_most_recent_receive: [],
                    alices_revocation_preimages: [],
                    alices_revocation_hashes: [],
                    bobs_revocation_preimages: [],
                    bobs_revocation_hashes: [],
                    txids_to_watch_for: {},
                    latest_force_close_txs: [],
                    extra_outputs: [],
                    pending_htlc: {},
                },
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                rmd160: s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var hash = RIPEMD160.create();
                    hash.update( new Uint8Array( s ) );
                    return hedgehog.bytesToHex( hash.digest() );
                },
                sha256: async s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var hash = await nobleSecp256k1.utils.sha256( new Uint8Array( s ) );
                    return hedgehog.bytesToHex( hash );                    
                },
                waitSomeSeconds: num => {
                    var num = num.toString() + "000";
                    num = Number( num );
                    return new Promise( resolve => setTimeout( resolve, num ) );
                },
                getInvoicePmthash: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var i; for ( i=0; i<decoded[ "tags" ].length; i++ ) {
                        if ( decoded[ "tags" ][ i ][ "tagName" ] == "payment_hash" ) var pmthash = decoded[ "tags" ][ i ][ "data" ].toString();
                    }
                    return pmthash;
                },
                getInvoiceAmount: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var amount = decoded[ "satoshis" ].toString();
                    return Number( amount );
                },
                isValidHex: hex => {
                    if ( !hex ) return;
                    var length = hex.length;
                    if ( length % 2 ) return;
                    try {
                        var bigint = BigInt( "0x" + hex, "hex" );
                    } catch( e ) {
                        return;
                    }
                    var prepad = bigint.toString( 16 );
                    var i; for ( i=0; i<length; i++ ) prepad = "0" + prepad;
                    var padding = prepad.slice( -Math.abs( length ) );
                    return ( padding === hex );
                },
                getVin: ( txid, vout, amnt, addy, sequence ) => {
                    var input = {
                        txid,
                        vout,
                        prevout: {
                            value: amnt,
                            scriptPubKey: tapscript.Address.toScriptPubKey( addy ),
                        },
                    }
                    if ( sequence ) input[ "sequence" ] = sequence;
                    return input;
                },
                getVout: ( amnt, addy ) => ({
                    value: amnt,
                    scriptPubKey: tapscript.Address.toScriptPubKey( addy ),
                }),
                makeAddress: ( scripts ) => {
                    var tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var pubkey = "ab".repeat( 32 );
                    var [ tpubkey ] = tapscript.Tap.getPubKey( pubkey, { tree });
                    return tapscript.Address.p2tr.fromPubKey( tpubkey, hedgehog.network );
                },
                makeAlicesRevocationScript: chan_id => ([
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ "OP_RIPEMD160", hedgehog.state[ chan_id ].alices_revocation_hashes[ hedgehog.state[ chan_id ].alices_revocation_hashes.length - 1 ], "OP_EQUALVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    //TODO: change the 10 to 4032
                    [ 10, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                ]),
                makeBobsRevocationScript: chan_id => ([
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ "OP_RIPEMD160", hedgehog.state[ chan_id ].bobs_revocation_hashes[ hedgehog.state[ chan_id ].bobs_revocation_hashes.length - 1 ], "OP_EQUALVERIFY", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG" ],
                    //TODO: change the 10 to 4032
                    [ 10, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG" ],
                ]),
                makeHTLC: ( chan_id, hash ) => ([
                    [ "OP_SIZE", 32, "OP_EQUALVERIFY", "OP_SHA256", hash, "OP_EQUALVERIFY", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                ]),
                openChannel: async ( push_all_funds_to_counterparty, alices_pubkey_and_hash = null, papa_swap_hash = null, utxos_for_papa_swap = null, deposit_amount = null, change_address = null, data = null ) => {
                    //there are three ways to open a channel:
                    //the first way is as Bob, opening a channel to Alice unilaterally
                    //the code for that appears after this "if" statement (not in it) because a
                    //unilateral channel open requires pushing all funds to your counterparty
                    //the second way is as Alice, accepting a channel Bob already unilaterally opened
                    //the third way is as Alice, opening a new channel cooperatively with Bob
                    //the second and third ways are handled in the first "if" statement below
                    //in theory there are two more ways: Bob could open a channel to Alice cooperatively
                    //and thus keep some or all of the funds on his side, or Alice could open a channel
                    //to Bob unilaterally and thus push all funds to Bob's side. To do these examples,
                    //just have Alice open a channel with push_all_funds_to_counterparty set to true
                    //or have Bob open a channel with push_all_funds_to_counterparty set to false
                    if ( !push_all_funds_to_counterparty ) {
                        if ( !data ) {
                            var has_data = confirm( `Click ok if someone sent you channel opening info or cancel if you are opening this channel yourself` );
                        } else {
                            has_data = true;
                        }
                        if ( has_data ) {
                            if ( !data ) data = JSON.parse( prompt( `Enter the data your counterparty sent you` ) );
                            //TODO: validate the data so you don't acccidentally accept irredeemable coins
                            //or crash your wallet

                            //create the state object
                            var pubkey = data[ "recipient_pubkey" ];
                            if ( !( pubkey in hedgehog.keypairs ) ) return alert( `Your counterparty tried to scam you! Do not interact with them any further` );
                            var privkey = hedgehog.keypairs[ pubkey ][ "privkey" ];
                            var preimage = hedgehog.keypairs[ pubkey ][ "preimage" ];
                            var chan_id = data[ "chan_id" ];
                            hedgehog.state[ chan_id ] = hedgehog.state_obj;
                            hedgehog.state[ chan_id ][ "alices_privkey" ] = privkey;
                            hedgehog.state[ chan_id ][ "alices_pubkey" ] = pubkey;
                            hedgehog.state[ chan_id ][ "bobs_pubkey" ] = data[ "sender_pubkey" ];
                            hedgehog.state[ chan_id ][ "multisig_utxo_info" ] = data[ "utxo_info" ];
                            hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                            var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                            hedgehog.state[ chan_id ].alices_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].alices_pubkey ], hedgehog.network );
                            hedgehog.state[ chan_id ].bobs_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].bobs_pubkey ], hedgehog.network );
                            var multisig_script = [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ];
                            var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                            hedgehog.state[ chan_id ].multisig_script = multisig_script;
                            hedgehog.state[ chan_id ].multisig_tree = multisig_tree;
                            hedgehog.state[ chan_id ].multisig = hedgehog.makeAddress( [ multisig_script ] );

                            //temporarily pretend the entire balance is on Bob's side so he can
                            //send it to Alice using the regular send command
                            var amnt = data[ "amnt" ];
                            hedgehog.state[ chan_id ].balances = [ 0, amnt ];
                            var opening = true;

                            //validate the initial state using the regular "receive" function
                            var opened = await hedgehog.receive( {amnt: amnt - 500 - 500, sig_1: data[ "sig_1" ], sig_3: data[ "sig_3" ], chan_id: data[ "chan_id" ], hash: data[ "hash" ]} );
                            if ( opened !== true ) return;

                            //update the state to reflect alice's ability to withdraw 100%
                            hedgehog.state[ chan_id ].balances = [ amnt, 0 ];

                            //update the send/receive/close buttons to use this channel
                            // $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                            // $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                            // $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                            // $( '.send_htlc_btn' ).onclick = async () => {
                            //     var chan_id = Object.keys( hedgehog.state )[ 0 ];
                            //     var amnt = Number( prompt( `enter an amount of sats you want to send to the htlc` ) );
                            //     var info_for_bob = await hedgehog.aliceSendsHtlc( chan_id, amnt );
                            // }
                            // alert( `yay, your channel is open!` );
                            return true;
                        } else {
                            // In this way, Alice does *not* receive data from Bob but instead
                            // opens a channel to him *cooperatively.* It is not yet implemented
                        }
                        return;
                    }

                    //handle the case where Bob opens a channel to Alice unilaterally
                    //start by preparing the state object
                    var chan_id = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    hedgehog.state[ chan_id ] = hedgehog.state_obj;
                    hedgehog.state[ chan_id ].bobs_privkey = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    hedgehog.state[ chan_id ].bobs_pubkey = nobleSecp256k1.getPublicKey( hedgehog.state[ chan_id ].bobs_privkey, true ).substring( 2 );
                    if ( !alices_pubkey_and_hash ) alices_pubkey_and_hash = JSON.parse( prompt( `Enter Alice's pubkey and revocation hash` ) );
                    hedgehog.state[ chan_id ].alices_pubkey = alices_pubkey_and_hash[ 0 ];
                    hedgehog.state[ chan_id ].alices_revocation_hashes.push( alices_pubkey_and_hash[ 1 ] );
                    hedgehog.state[ chan_id ].alices_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].alices_pubkey ], hedgehog.network );
                    hedgehog.state[ chan_id ].bobs_address = tapscript.Address.fromScriptPubKey( [ "OP_1", hedgehog.state[ chan_id ].bobs_pubkey ], hedgehog.network );
                    var multisig_script = [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIGVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ];
                    var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                    hedgehog.state[ chan_id ].multisig_script = multisig_script;
                    hedgehog.state[ chan_id ].multisig_tree = multisig_tree;
                    hedgehog.state[ chan_id ].multisig = hedgehog.makeAddress( [ multisig_script ] );
                    if ( papa_swap_hash ) {
                        //we are using a papa swap so a transaction needs to go from the multisig to a
                        //revocable address; and a 2 week timelock from the revocable address should give
                        //the funds back to Bob; but if he revokes this path, then of course Alice can
                        //sweep it if Bob tries to use it, because she will have the revocation preimage.
                        var vin = [];
                        var sum = 0;
                        utxos_for_papa_swap.forEach( utxo => {
                            sum = sum + utxo.amnt;
                            vin.push( hedgehog.getVin( utxo.txid, utxo.vout, utxo.amnt, utxo.addy ) );
                        });
                        var papa_swap_funding_tx = tapscript.Tx.create({
                            vin,
                            vout: [hedgehog.getVout( deposit_amount, hedgehog.state[ chan_id ].multisig )],
                        });
                        var deposit_mining_txfee = 500;
                        if ( sum - deposit_amount - deposit_mining_txfee > 330 ) {
                            papa_swap_funding_tx.vout.push( hedgehog.getVout( sum - deposit_amount - deposit_mining_txfee, change_address ) );
                        }
                        var i; for ( i=0; i<papa_swap_funding_tx.vin.length; i++ ) {
                            var utxo = utxos_for_papa_swap[ i ];
                            var sig = tapscript.Signer.taproot.sign( utxo[ "skey" ], papa_swap_funding_tx, 0 ).hex;
                            papa_swap_funding_tx.vin[ i ].witness = [ sig ];
                        }
                        var funding_txhex = tapscript.Tx.encode( papa_swap_funding_tx ).hex;
                        var txid = tapscript.Tx.util.getTxid( papa_swap_funding_tx );
                        var utxos_created = [];
                        if ( sum - deposit_amount - deposit_mining_txfee > 330 ) {
                            utxos_created.push( {txid, vout: 1, amnt: sum - deposit_amount - deposit_mining_txfee, addy: change_address } );
                        }
                        var vout = 0;
                        var amnt = deposit_amount;

                        var revocable_scripts = [
                            [
                                2016,
                                "OP_CHECKSEQUENCEVERIFY",
                                "OP_DROP",
                                hedgehog.state[ chan_id ].bobs_pubkey,
                                "OP_CHECKSIG",
                            ],
                            [
                                "OP_SIZE",
                                32,
                                "OP_EQUALVERIFY",
                                "OP_SHA256",
                                papa_swap_hash,
                                "OP_EQUALVERIFY",
                                hedgehog.state[ chan_id ].alices_pubkey,
                                "OP_CHECKSIG",
                            ]
                        ];

                        var revocable_address = hedgehog.makeAddress( revocable_scripts );

                        hedgehog.state[ chan_id ].multisig_utxo_info = {
                            txid,
                            vout,
                            amnt,
                        }

                        //temporarily pretend the entire balance is on Bob's side so he can
                        //send it to Alice using the regular send command
                        hedgehog.state[ chan_id ].balances = [ 0, amnt ];

                        //prepare the transaction that moves all funds to Alice's side
                        var opening = true;
                        var sigs_and_stuff = hedgehog.send( chan_id, amnt - 500 - 500, opening );
                        sigs_and_stuff[ "amnt" ] = amnt;

                        //update the state to reflect alice's ability to withdraw 100%
                        hedgehog.state[ chan_id ].balances = [ amnt, 0 ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ amnt, 0 ];

                        // update the send/receive/close buttons to use this channel
                        // $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                        // $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                        // $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                        // alert( `yay, your channel is funded! send your counterparty the info in your console` );
                        return [ chan_id, sigs_and_stuff, funding_txhex, utxos_created ];
                    }
                    console.log( "address:", hedgehog.state[ chan_id ].multisig );

                    var txid = prompt( `send some sats to this address and give the txid:\n\n${hedgehog.state[ chan_id ].multisig}` );
                    var vout = Number( prompt( `and the vout` ) );
                    var amnt = Number( prompt( `and the amount` ) );
                    hedgehog.state[ chan_id ].multisig_utxo_info = {
                        txid,
                        vout,
                        amnt,
                    }

                    //temporarily pretend the entire balance is on Bob's side so he can
                    //send it to Alice using the regular send command
                    hedgehog.state[ chan_id ].balances = [ 0, amnt ];

                    //prepare the transaction that moves all funds to Alice's side
                    var opening = true;
                    var sigs_and_stuff = hedgehog.send( chan_id, amnt - 500 - 500, opening );
                    sigs_and_stuff[ "amnt" ] = amnt;
                    console.log( "send this data to your recipient:" );
                    console.log( JSON.stringify( sigs_and_stuff ) );

                    //update the state to reflect alice's ability to withdraw 100%
                    hedgehog.state[ chan_id ].balances = [ amnt, 0 ];
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ amnt, 0 ];

                    //update the send/receive/close buttons to use this channel
                    $( '.send_btn' ).onclick = () => {console.log( "send this data to your recipient:" );console.log( JSON.stringify( hedgehog.send( chan_id ) ) );}
                    $( '.receive_btn' ).onclick = () => {hedgehog.receive();}
                    $( '.close_channel' ).onclick = () => {hedgehog.closeChannel( chan_id );}
                    alert( `yay, your channel is funded! send your counterparty the info in your console` );
                },
                send: ( chan_id, amnt, opening, skip_pending_check ) => {
                    if ( !skip_pending_check && Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //unless an amount is already given, prompt the user to enter an amount
                    if ( !amnt ) amnt = Number( prompt( `Please enter an amount you want to send to your counterparty` ) );

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create tx1 to distribute the funds however the sender wishes to do so
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [],
                    });

                    //increase the recipient's balance by amnt and decrease the sender's by
                    //amnt and two mining fees
                    if ( am_alice ) {
                        var amnt_for_alice = balances[ 0 ] - amnt - 500 - 500;
                        var amnt_for_bob = balances[ 1 ] + amnt;
                    } else {
                        var amnt_for_alice = balances[ 0 ] + amnt;
                        var amnt_for_bob = balances[ 1 ] - amnt - 500 - 500;
                        if ( opening ) var amnt_for_bob = 0;
                    }
                    if ( am_alice ) {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }
                    // console.log( "tx0:", JSON.stringify( tx0 ) );
                    // console.log( "tx1:", JSON.stringify( tx1 ) );

                    //Sign both of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 2016 blocks
                    //because tx1's only input (see above) has sequence number 2016
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }
                    //Create an object to send all this data to the recipient
                    var object = {
                        sig_1,
                        sig_3,
                        hash,
                        amnt,
                        chan_id,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;
                    if ( opening ) object[ "utxo_info" ] = utxo_info;
                    if ( opening ) object[ "sender_pubkey" ] = hedgehog.state[ chan_id ].bobs_pubkey;
                    if ( opening ) object[ "recipient_pubkey" ] = hedgehog.state[ chan_id ].alices_pubkey;

                    //update the balances
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                    } else {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    return object;
                },
                receive: async ( data, skip_pending_check ) => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    if ( !skip_pending_check && Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) {
                            if ( amnt <= hedgehog.state[ chan_id ].balances[ 0 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 0 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );                            
                        } else {
                            if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        }
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var amnt = data[ "amnt" ];
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create tx1 to distribute the funds however the sender wishes to do so
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [],
                    });

                    //increase the recipient's balance by amnt and decrease the sender's by
                    //amnt and two mining fees
                    if ( am_alice ) {
                        var amnt_for_alice = balances[ 0 ] + amnt;
                        var amnt_for_bob = balances[ 1 ] - amnt - 500 - 500;
                        if ( data_was_here_originally ) var amnt_for_bob = 0;
                    } else {
                        var amnt_for_alice = balances[ 0 ] - amnt - 500 - 500;
                        var amnt_for_bob = balances[ 1 ] + amnt;
                    }
                    if ( am_alice ) {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }
                    // console.log( "tx0:", JSON.stringify( tx0 ) );
                    // console.log( "tx1:", JSON.stringify( tx1 ) );

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );
                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign both of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //if necessary, prepare and save the full revocation transaction
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //update the balances
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                    } else {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    return true;
                },
                aliceSendsHtlc: async ( chan_id, amnt, htlc_hash = null, invoice_to_pay ) => {
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and you want to make an htlc worth less than that, i.e. only ${amnt} sats, so it cannot be done -- the software refuses and your only recourse is to find or make a modified version that allows dust htlcs` );
                    console.log( amnt );
                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );
                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;
                    if ( !am_alice ) return;

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create the htlc
                    if ( !htlc_hash ) {
                        var htlc_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                        htlc_hash = await hedgehog.sha256( hedgehog.hexToBytes( htlc_preimage ) );
                    } else {
                        var htlc_preimage = null;
                    }
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 1996
                        //note that it is 20 blocks less than 2016 because below, we will give
                        //second_from_htlc_tx a timelock of 2026, 10 blocks longer than any LN invoice (so the
                        //operator can't be screwed by paying a 2016 block lightning invoice),
                        //and we want the sum of that timelock plus this one (2026+1996) to be
                        //10 blocks less than 4032, that way the operator can't be stolen from
                        //on the grounds that he disappeared
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create first_from_htlc_tx to disperse the funds from the htlc to the new state if
                    //Bob discloses his knowledge of the preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                            hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                        ],
                    });

                    //create second_from_htlc_tx to disperse the funds from the htlc to the current state
                    //if Bob does not disclose his knowledge of the preimage in time
                    var amnt_for_alice = balances[ 0 ] - 500 - 500 - 500;
                    var amnt_for_bob = balances[ 1 ];
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2026
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 1996 blocks
                    //because tx1's only input (see above) has sequence number 1996
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    //alices_first_htlc_sig is for first_from_htlc_tx which lets Bob create the latest
                    //state if he learns the preimage
                    var alices_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    //alices_second_htlc_sig is for second_from_htlc_tx which restores the current state
                    //if Bob doesn't learn the preimage in time
                    var alices_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                                hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                            ],
                        });
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2026
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                        var alices_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var alices_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    //collect info to send to bob
                    var info_for_bob = {
                        alices_first_htlc_sig,
                        alices_second_htlc_sig,
                        htlc_hash,
                        hash,
                        amnt,
                        chan_id,
                        alices_conditional_first_htlc_sig,
                        alices_conditional_second_htlc_sig,
                    }

                    //don't send the rest of the data til Bob cosigns first_from_htlc_tx and second_from_htlc_tx
                    //and the conditional versions thereof
                    // console.log( `send this info to bob:` );
                    // console.log( JSON.stringify( info_for_bob ) );
                    var recipient = $_GET[ "layer2" ];
                    var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                    var nostr_privkey = l2generator.state.depositor_data[ depositor_id ].nostr_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var secret = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "initiate_ln_payment",
                        msg: {
                            info_for_bob,
                            secret,
                            invoice_to_pay,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_bob = await getNote( secret );
                    sessionStorage.removeItem( secret );
                    var { secret_for_responding_to_bob } = JSON.parse( preparsed_info_from_bob );
                    var info_from_bob = JSON.parse( preparsed_info_from_bob )[ "data_for_alice" ];
                    var { bobs_first_htlc_sig, bobs_second_htlc_sig, bobs_conditional_first_htlc_sig, bobs_conditional_second_htlc_sig } = info_from_bob;
                    // var { bobs_first_htlc_sig, bobs_second_htlc_sig, bobs_conditional_first_htlc_sig, bobs_conditional_second_htlc_sig } = JSON.parse( prompt( `send the info in your console to bob and enter his reply -- btw he should be running hedgehog.bobReceivesHTLC()` ) );

                    //validate the sigs
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_first_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_first_htlc_sig, first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var bobs_second_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_second_htlc_sig, second_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var new_first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_conditional_htlc_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_first_htlc_sig, new_first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var new_second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var bobs_conditional_htlc_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_second_htlc_sig, new_second_from_htlc_tx_sighash, pubkey_to_validate_against );
                    if ( !bobs_first_htlc_sig_is_valid || !bobs_second_htlc_sig_is_valid || !bobs_conditional_htlc_1_sig_is_valid || !bobs_conditional_htlc_2_sig_is_valid ) {
                        //restore previous state
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                        return;
                    }

                    //send bob the rest of the data

                    //Create an object to send all this data to the recipient
                    //but don't send him the htlc_preimage -- that's for Alice
                    //only
                    var object = {
                        sig_1,
                        sig_3,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;

                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify( object ),
                            secret: secret_for_responding_to_bob,
                        }
                    });
                    var recipient = $_GET[ "layer2" ];
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );

                    // console.log( `send this info to bob:` );
                    // console.log( JSON.stringify( object ) );
                    // alert( `send the info in your console to bob and then click ok` );

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    console.log( "prev_tx0:" );
                    console.log( prev_force_close_tx );

                    if ( htlc_preimage ) {
                        console.log( 'here is the preimage your counterparty needs, they should run hedgehog.settleIncomingHTLC() and enter it' );
                        console.log( JSON.stringify({chan_id, preimage: htlc_preimage}) );
                    }

                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "alice",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage,
                        htlc_hash,
                        force_close_tx: prev_force_close_tx,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        restore_current_state_after_force_close: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                        //note that the timeout_tx is there in case your counterparty disappears after you
                        //force close -- Alice can EITHER sweep the money using the timeout tx after 4032
                        //blocks, if Bob disappears entirely, or -- if she force closes and then Bob at
                        //least sticks around long enough to move the money into the htlc, but then doesn't
                        //disclose the preimage within 2026 blocks, Alice can sweep back her funds using
                        //the new_second_from_htlc_tx
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                        time_til_timeout_tx: 4032,
                    }

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Bob can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Alice's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    //TODO: if you have the preimage, send it to whoever you're sending money to
                    //and remember to also tell them whatever amount you are sending so
                    //they can set up a scenario where they gain that much money if they
                    //disclose the preimage to bob
                },
                bobReceivesHTLC: async ( data, secret_for_responding_to_alice, alices_nostr_pubkey, invoice_to_pay ) => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    var amnt = data[ "amnt" ];
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and this htlc is worth only ${amnt} sats so we reject it` );
                    if ( amnt > hedgehog.state[ chan_id ].balances[ 0 ] ) return alert( `alice tried to send you more money than she has so we reject it` );
                    //TODO: ensure checking the invoice here doesn't crash my app
                    var invoice_amt = hedgehog.getInvoiceAmount( invoice_to_pay );
                    //TODO: let the operator charge a fee to pay invoices
                    if ( invoice_amt > amnt ) return alert( `alice tried to send you less money than the invoice she wants you to pay` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create the htlc
                    var htlc_hash = data[ "htlc_hash" ];
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 1996
                        //note that it is 20 blocks less than 2016 because below, we will give
                        //second_from_htlc_tx a timelock of 2026, 10 blocks longer than any LN invoice (so the
                        //operator can't be screwed by paying a 2016 block lightning invoice),
                        //and we want the sum of that timelock plus this one (2026+1996) to be
                        //10 blocks less than 4032, that way the operator can't be stolen from
                        //on the grounds that he disappeared
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create first_from_htlc_tx to disperse the funds from the htlc to the new state if
                    //Bob discloses his knowledge of the preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                            hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                        ],
                    });

                    //create second_from_htlc_tx to disperse the funds from the htlc to the current state
                    //if Bob does not disclose his knowledge of the preimage in time
                    var amnt_for_alice = balances[ 0 ] - 500 - 500 - 500;
                    var amnt_for_bob = balances[ 1 ];
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2026
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var alices_first_htlc_sig = data[ "alices_first_htlc_sig" ];
                    var sighash_first_htlc = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var is_valid_first_htlc = await nobleSecp256k1.schnorr.verify( alices_first_htlc_sig, sighash_first_htlc, pubkey_to_validate_against );
                    var alices_second_htlc_sig = data[ "alices_second_htlc_sig" ];
                    var sighash_second_htlc = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var is_valid_second_htlc = await nobleSecp256k1.schnorr.verify( alices_second_htlc_sig, sighash_second_htlc, pubkey_to_validate_against );

                    if ( !is_valid_first_htlc || !is_valid_second_htlc ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    var bobs_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] - 500 - 500 - 500 - amnt, alices_address ),
                                hedgehog.getVout( balances[ 1 ] + amnt, bobs_address ),
                            ],
                        });
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2026
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_second_from_htlc_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var alices_conditional_first_htlc_sig = data[ "alices_conditional_first_htlc_sig" ];
                        var conditional_htlc_1_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var conditional_htlc_1_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_first_htlc_sig, conditional_htlc_1_sighash, pubkey_to_validate_against );
                        var bobs_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var alices_conditional_second_htlc_sig = data[ "alices_conditional_second_htlc_sig" ];
                        var conditional_htlc_2_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var conditional_htlc_2_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_second_htlc_sig, conditional_htlc_2_sighash, pubkey_to_validate_against );
                        var bobs_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        if ( !conditional_htlc_1_is_valid || !conditional_htlc_2_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                    }

                    var data_for_alice = {
                        bobs_first_htlc_sig,
                        bobs_second_htlc_sig,
                    }
                    if ( bobs_conditional_first_htlc_sig ) data_for_alice[ "bobs_conditional_first_htlc_sig" ] = bobs_conditional_first_htlc_sig;
                    if ( bobs_conditional_second_htlc_sig ) data_for_alice[ "bobs_conditional_second_htlc_sig" ] = bobs_conditional_second_htlc_sig;

                    // console.log( `send this data to alice:` );
                    // console.log( JSON.stringify( data_for_alice ) );

                    var l2id = Object.keys( l2generator.state.l2s )[ 0 ];
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var recipient = alices_nostr_pubkey;
                    var secret_for_responding_to_bob = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify({
                                data_for_alice, secret_for_responding_to_bob
                            }),
                            secret: secret_for_responding_to_alice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_alice = await getNote( secret_for_responding_to_bob );
                    sessionStorage.removeItem( secret_for_responding_to_bob );
                    var data = JSON.parse( preparsed_info_from_alice );

                    // alert( `send the data in your console to alice and then click ok` );
                    // await hedgehog.waitSomeSeconds( 1 );
                    // var data = JSON.parse( prompt( `enter alice's reply here` ) );

                    //validate the rest of the data sent by your counterparty

                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );

                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //prepare the transaction that uses the htlc to create the new state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    if ( am_alice ) first_from_htlc_tx.vin[ 0 ].witness = [ alices_first_htlc_sig, bobs_first_htlc_sig, first_htlc_script, cblock ];
                    else first_from_htlc_tx.vin[ 0 ].witness = [ bobs_first_htlc_sig, alices_first_htlc_sig, first_htlc_script, cblock ];

                    //prepare the transaction that uses the htlc to restore the current state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    if ( am_alice ) second_from_htlc_tx.vin[ 0 ].witness = [ alices_second_htlc_sig, bobs_second_htlc_sig, second_htlc_script, cblock ];
                    else second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];

                    //if necessary, prepare and save the full revocation transactions
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                            new_first_from_htlc_tx.vin[ 0 ].witness = [ alices_conditional_first_htlc_sig, bobs_conditional_first_htlc_sig, first_htlc_script, cblock ];
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                            new_second_from_htlc_tx.vin[ 0 ].witness = [ alices_conditional_second_htlc_sig, bobs_conditional_second_htlc_sig, second_htlc_script, cblock ];
                        } else {
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                            new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_first_htlc_sig, alices_conditional_first_htlc_sig, first_htlc_script, cblock ];
                            var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                            new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];
                        }
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                            conditional_second_htlc_tx: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Bob can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Alice's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "alice",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage: null,
                        htlc_hash,
                        force_close_tx: tapscript.Tx.encode( tx0 ).hex,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        from_force_close_to_htlc: tapscript.Tx.encode( tx1 ).hex,
                        when_to_fund_htlc: 1996, //shorter than normal so that 4032 blocks is never exceeded
                        unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                        restore_current_state_after_force_close: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                        when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                        txid_to_watch_for: prev_txid,
                        replacement_tx1_if_txid_to_watch_for_is_seen: tapscript.Tx.encode( new_tx1 ).hex,
                        //remember to decode the following tx, then make the preimage the item in
                        //the witness stack closest to the script, then reencode it, then broadcast it
                        conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                        restore_current_state_after_replacement_tx1: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        channels_with_pending_outgoing_htlcs_linked_to_this_one: {},
                        time_when_preimage_was_received: null,
                        time_to_wait_after_preimage_is_received: 2016,
                    }

                    //test the following scenarios:

                    // console.log( `first test tx0 (bob) tx1 (bob) second_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_second_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_second_from_htlc_tx (alice) [tested by proxy -- I checked that her copy of new_second_from_htlc_tx is identical to bob's, so it will necessarily work too if he broadcasts replacement_tx1]` );
                    // console.log( `next test tx0 (bob) tx1 (bob) first_from_htlc_tx (bob) [tested]` );
                    // console.log( `next test prev_tx0 (alice) replacement_tx1 (bob) new_first_from_htlc_tx (bob) [tested]` );

                    //note that I was gonna have Bob broadcast *his* prev_tx0 and then
                    //have *Alice* broadcast *her* replacement_tx1 but that won't
                    //result in the htlc getting created -- it will just mean they
                    //go to the state *before* the htlc was created, in which Alice
                    //had more money coming to her

                    //TODO: set up a listener to get the preimage from somewhere
                    //or restore the old state after too much time goes by without resolution

                    //i am bob

                    return invoice_to_pay;
                },
                bobSendsHtlc: async ( chan_id, amnt, htlc_hash = null, invoice = null, alices_nostr_pubkey, l2id ) => {
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and you want to make an htlc worth less than that, i.e. only ${amnt} sats, so it cannot be done -- the software refuses and your only recourse is to find or make a modified version that allows dust htlcs` );
                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot send money while you have one...clear it before proceeding` );
                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;
                    if ( am_alice ) return;

                    var recipient = alices_nostr_pubkey;
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var nwc_string = l2generator.state.l2s[ l2id ].nwc_string;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var secret = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "get_revocation_data",
                        msg: {
                            secret,
                            chan_id,
                            amnt,
                            invoice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_alice = await getNote( secret );
                    sessionStorage.removeItem( secret );
                    var { alices_revocation_hash, secret_for_responding_to_alice } = JSON.parse( preparsed_info_from_alice );
                    // console.log( JSON.stringify({ chan_id, amnt }) );
                    // var alices_revocation_data = JSON.parse( prompt( 'send the data in your console to alice and enter her reply here -- she should run hedgehog.aliceReceivesHTLC()' ) );
                    // var alices_revocation_hash = alices_revocation_data[ "alices_revocation_hash" ];

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create the htlc
                    if ( !htlc_hash ) {
                        var htlc_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                        htlc_hash = await hedgehog.sha256( hedgehog.hexToBytes( htlc_preimage ) );
                    } else {
                        var htlc_preimage = null;
                    }
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: there's no sequence number because this is expected to be used
                        //when Alice is receiving a lightning payment, and the htlc will have
                        //a timelock of 20 blocks, 20 because every hop on an LN path increases
                        //the timelock and most wallets have a max timelock of only 2016 blocks
                        //-- but, to ensure Alice isn't screwed if she goes offline for 20
                        //blocks, we'll make it so that, after the 20 blocks expire, Bob can
                        //only sweep the funds into a revocable address that *does* have a
                        //2016 block timelock before he can sweep them from *there* -- and then,
                        //when updating the state, Bob will revoke his ability to withdraw from
                        //the revocable address
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create an address that Alice can revoke later -- I will reuse
                    //makeHTLC for this because she can revoke this one by revealing
                    //its preimage after signing a tx that lets Bob sweep it if he
                    //learns the preimage
                    var alices_revocation_scripts = hedgehog.makeHTLC( chan_id, alices_revocation_hash );
                    var alices_revocation_address = hedgehog.makeAddress( alices_revocation_scripts );

                    //create first_from_htlc_tx to disperse the funds from the htlc to Alice's
                    //revocation_address if Alice discloses her knowledge of the payment preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                            hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                        ],
                    });
                    var first_from_htlc_txid = tapscript.Tx.util.getTxid( first_from_htlc_tx );

                    //note that this revocation path requires Alice to disclose alices_revocation_preimage
                    //which means it uses the first path in alices_revocation_scripts
                    //she should only do this once the new state has been created
                    //if Alice revokes this state the following tx lets Bob sweep the funds
                    var from_revo_tx_1 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                        ],
                    });

                    //this one actually disperses the funds to Alice but only after a 20 block timelock
                    //it also uses the second path in alices_revocation_scripts
                    var from_revo_tx_2 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                        vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                    });

                    //create an address that Bob can revoke later -- I will reuse
                    //makeHTLC for this because he can revoke this one by revealing
                    //its preimage after signing a tx that lets Alice sweep it if
                    //she learns the preimage
                    var revocation_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    var revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( revocation_preimage ) );
                    var revocation_scripts = hedgehog.makeHTLC( chan_id, revocation_hash );
                    var revocation_address = hedgehog.makeAddress( revocation_scripts );

                    //create second_from_htlc_tx to move the funds into the revocation addy with a 20 block
                    //timelock if Alice does not disclose her knowledge of the preimage in a timely manner
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 20
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                    });
                    var htlc_2_txid = tapscript.Tx.util.getTxid( second_from_htlc_tx );

                    //create restore_from_revo_tx to disperse the funds from the revocation address to
                    //restore the current state if Bob did not revoke this address (for use when Alice
                    //won't disclose the preimage in the "happy path" so he forces her to do so or go
                    //back to the prior state, or, if he tries to do this just because he thinks she will
                    //be offline for 20 blocks, she gets 2016 blocks to show he revoked this path and
                    //penalize him)
                    //TODO: ensure Alice cannot put the money in the revocation address after Bob revokes
                    //it -- note that I thought for a second Alice could broadcast the *prior* state and
                    //thus force Bob to "update" the state to the one where the money is in the htlc, from
                    //which he is screwed because he can only move it from there to the state where Alice
                    //gets the new state as of this state update, or into the revocation address; but that
                    //is not true for two reasons: first, Alice will revoke that state shortly, so she
                    //cannot do that; and even if she didn't, Alice can only force closes into the state
                    //when she last sent money, in which case she loses the money she gains through this
                    //transaction -- so Bob can just let her lose that money.
                    //And I don't think Alice has any other opportunity to put the money in the revocation
                    //address after Bob revokes it -- he will only revoke it after they've created the
                    //new state and Alice has fully revoked this one, so if she tries to get it into the
                    //revocation address later, she will be screwed
                    var amnt_for_alice = balances[ 0 ];
                    var amnt_for_bob = balances[ 1 ] - 500 - 500 - 500 - 500;
                    var restore_from_revo_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //create bob_tried_to_cheat_tx that lets Alice sweep the funds if
                    //Bob tries to restore the current state after revoking it
                    var bob_tried_to_cheat_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                    });

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires,
                    //and sign bob_tried_to_cheat_tx with the path that requires
                    //Bob to reveal his preimage for Alice to use it (i.e. the first
                    //path)
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var alices_first_revo_script = alices_revocation_scripts[ 0 ];
                    var alices_first_revo_target = tapscript.Tap.encodeScript( alices_first_revo_script );
                    var alices_second_revo_script = alices_revocation_scripts[ 1 ];
                    var alices_second_revo_target = tapscript.Tap.encodeScript( alices_second_revo_script );
                    var alices_revo_tree = alices_revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_revo_script = revocation_scripts[ 0 ];
                    var first_revo_target = tapscript.Tap.encodeScript( first_revo_script );
                    var revo_tree = revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_revo_script = revocation_scripts[ 1 ];
                    var second_revo_target = tapscript.Tap.encodeScript( second_revo_script );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 1996 blocks
                    //because tx1's only input (see above) has sequence number 1996
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    //bobs_first_htlc_sig is for first_from_htlc_tx which lets Alice create the latest
                    //state if she discloses the preimage
                    var bobs_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var bobs_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var bobs_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;

                    //bobs_second_htlc_sig is for second_from_htlc_tx which restores the current state
                    //if Alice doesn't disclose the preimage in time -- or lets Alice sweep all of Bob's
                    //funds if he revokes this state and then puts the money in this state anyway
                    var bobs_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    //bobs_restoration_sig is for restore_from_revo_tx which disperses the funds from the
                    //revocation address to restore the current state if Bob did not revoke this address
                    //(for use when Alice won't disclose the preimage in the "happy path" so he forces her
                    //to do so or go back to the prior state, or, if he tries to do this just because he
                    //thinks she will be offline for 20 blocks, she gets 2016 blocks to show he revoked
                    //this path and penalize him)
                    var bobs_restoration_sig = tapscript.Signer.taproot.sign( privkey, restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    //bobs_cheater_sig is for bob_tried_to_cheat_tx which lets Alice sweep the funds if
                    //Bob tries to restore the current state after revoking it
                    var bobs_cheater_sig = tapscript.Signer.taproot.sign( privkey, bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                                hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                            ],
                        });
                        var new_first_from_htlc_txid = tapscript.Tx.util.getTxid( new_first_from_htlc_tx );
                        var new_from_revo_tx_1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                            ],
                        });
                        var new_from_revo_tx_2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                            vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                        });
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 20
                            vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                        });
                        var new_htlc_2_txid = tapscript.Tx.util.getTxid( new_second_from_htlc_tx );
                        var new_restore_from_revo_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2016
                            vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_bob_tried_to_cheat_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                        });

                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                        var bobs_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var bobs_conditional_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, new_from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var bobs_conditional_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, new_from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var bobs_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var bobs_conditional_restoration_sig = tapscript.Signer.taproot.sign( privkey, new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        var bobs_conditional_cheater_sig = tapscript.Signer.taproot.sign( privkey, new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    //collect info to send to alice
                    //it is important that Alice not be able
                    //to force Bob to put money into the revocation
                    //address after he has revoked it
                    var info_for_alice = {
                        bobs_first_htlc_sig,
                        bobs_revo_tx_1_sig,
                        bobs_revo_tx_2_sig,
                        bobs_second_htlc_sig,
                        // I don't think Alice should know the
                        // restoration sig otherwise once the
                        // money moves into the revocation
                        // address after a new state update
                        // she can broadcast the restoration
                        // tx and restore an old state
                        //bobs_restoration_sig,
                        // I think it is fine for her to have
                        // bobs_second_htlc_sig because that
                        // one is timelocked for 20 blocks
                        // which should give Bob time to
                        // broadcast first_from_htlc_tx
                        // instead -- though this *also*
                        // restores the state created by
                        // this transaction, so I also
                        // ensure Alice can revoke that
                        // state so Bob can penalize her
                        // if she tries to broadcast this
                        // state later -- and this also
                        // means Bob must never have the
                        // sigs he needs to broadcast
                        // first_from_htlc_tx on his own
                        // -- but that's a contradiction
                        // -- I just said he needs to be
                        // able to broadcast that if
                        // Alice restores this state. Ok
                        // maybe he can only do that *if*
                        // her restoration tx reveals a
                        // piece of data he needs to do
                        // that. But duh, of course it
                        // does: Alice alone can restore
                        // this state once Bob has
                        // conditionally revoked it --
                        // he cannot do that on his own
                        // so I think all is well
                        bobs_cheater_sig,
                        htlc_hash,
                        revocation_hash,
                        hash,
                        amnt,
                        chan_id,
                        bobs_conditional_first_htlc_sig,
                        bobs_conditional_second_htlc_sig,
                        bobs_conditional_revo_tx_1_sig,
                        bobs_conditional_revo_tx_2_sig,
                        // removing the following one for
                        // the same lengthy reason I gave
                        // above
                        // bobs_conditional_restoration_sig,
                        bobs_conditional_cheater_sig,
                    }

                    var recipient = alices_nostr_pubkey;
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var secret_2_for_responding_to_bob = super_nostr.getPrivkey();
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify({
                                data: info_for_alice,
                                secret_2_for_responding_to_bob,
                            }),
                            secret: secret_for_responding_to_alice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );
                    var preparsed_info_from_alice = await getNote( secret_2_for_responding_to_bob );
                    sessionStorage.removeItem( secret_2_for_responding_to_bob );

                    var { data, secret_2_for_responding_to_alice } = JSON.parse( preparsed_info_from_alice );

                    //don't send the rest of the data til alice cosigns first_from_htlc_tx and second_from_htlc_tx
                    //and the restoration_tx and the conditional versions thereof
                    // console.log( `send this info to alice:` );
                    // console.log( JSON.stringify( info_for_alice ) );
                    // var { alices_first_htlc_sig, alices_revo_tx_1_sig, alices_revo_tx_2_sig, alices_second_htlc_sig, alices_restoration_sig, alices_conditional_first_htlc_sig, alices_conditional_revo_tx_1_sig, alices_conditional_revo_tx_2_sig, alices_conditional_second_htlc_sig, alices_conditional_restoration_sig } = JSON.parse( prompt( `send the info in your console to alice and enter her reply` ) );
                    var { alices_first_htlc_sig, alices_revo_tx_1_sig, alices_revo_tx_2_sig, alices_second_htlc_sig, alices_restoration_sig, alices_conditional_first_htlc_sig, alices_conditional_revo_tx_1_sig, alices_conditional_revo_tx_2_sig, alices_conditional_second_htlc_sig, alices_conditional_restoration_sig } = data;

                    //validate the sigs
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var alices_first_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_first_htlc_sig, first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var revo_tx_1_sighash = tapscript.Signer.taproot.hash( from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var alices_revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_revo_tx_1_sig, revo_tx_1_sighash, pubkey_to_validate_against );
                    var revo_tx_2_sighash = tapscript.Signer.taproot.hash( from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                    var alices_revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_revo_tx_2_sig, revo_tx_2_sighash, pubkey_to_validate_against );

                    var second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var alices_second_htlc_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_second_htlc_sig, second_from_htlc_tx_sighash, pubkey_to_validate_against );

                    var restoration_tx_sighash = tapscript.Signer.taproot.hash( restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    var alices_restoration_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_restoration_sig, restoration_tx_sighash, pubkey_to_validate_against );
                    var new_restoration_tx_sighash = tapscript.Signer.taproot.hash( new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    var alices_conditional_restoration_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_restoration_sig, new_restoration_tx_sighash, pubkey_to_validate_against );

                    var new_first_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var alices_conditional_htlc_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_first_htlc_sig, new_first_from_htlc_tx_sighash, pubkey_to_validate_against );
                    var new_second_from_htlc_tx_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var alices_conditional_htlc_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( alices_conditional_second_htlc_sig, new_second_from_htlc_tx_sighash, pubkey_to_validate_against );
                    if ( !alices_first_htlc_sig_is_valid || !alices_second_htlc_sig_is_valid || !alices_conditional_htlc_1_sig_is_valid || !alices_conditional_htlc_2_sig_is_valid || !alices_restoration_sig_is_valid || !alices_conditional_restoration_sig_is_valid || !alices_revo_tx_1_sig_is_valid || !alices_revo_tx_2_sig_is_valid ) {
                        //restore previous state
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                        return;
                    }

                    //send alice the rest of the data

                    //Create an object to send all this data to the recipient
                    //but don't send her the htlc_preimage -- that's for Bob
                    //only
                    //I forgot that Bob will only know the preimage
                    //when he creates an invoice that pays Alice -- in every
                    //other case, Alice will know the preimage and Bob will
                    //be trying to learn it -- so I made a todo to figure out
                    //what to do about that. I thought about it and decided to
                    //make it so that Bob is by default the one who knows
                    //the preimage, and if someone wants this to work
                    //differently they can modify it
                    var object = {
                        sig_1,
                        sig_3,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;

                    var recipient = alices_nostr_pubkey;
                    var nostr_privkey = l2generator.state.l2s[ l2id ].l2_privkey;
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var msg = JSON.stringify({
                        type: "secret_you_need",
                        msg: {
                            thing_needed: JSON.stringify( object ),
                            secret: secret_2_for_responding_to_alice,
                        }
                    });
                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                    super_nostr.sendEvent( event, socket );

                    // console.log( `send this info to alice:` );
                    // console.log( JSON.stringify( object ) );
                    // alert( `send the info in your console to alice and then click ok` );

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    console.log( "prev_tx0:" );
                    console.log( prev_force_close_tx );

                    if ( htlc_preimage ) {
                        console.log( 'here is the preimage your counterparty needs, they should run hedgehog.settleIncomingHTLC() and enter it' );
                        console.log( JSON.stringify({chan_id, preimage: htlc_preimage}) );
                    }

                    //if I force close, Alice can broadcast new_tx1, which puts the money in the htlc,
                    //so I need to prepare new_first_from_htlc_tx (which gives Alice her money if this
                    //is the latest state or will soon let bob penalize her otherwise)
                    //I also need to prepare new_second_from_htlc_tx. It
                    //moves the money into the revocation address -- if Alice has revoked her state,
                    //I should not broadcast new_second_from_htlc_tx but rather new_first_from_htlc_tx
                    //and then penalize her; otherwise, I have two options: I should either broadcast
                    //new_first_from_htlc_tx if the sender paid me, and that results in Alice getting
                    //her money; or, if he did not, I should broadcast new_second_from_htlc_tx to
                    //restore the current state.
                    //consequently, after new_second_from_htlc_tx I need to prepare
                    //new_restore_from_revo_tx so that I can restore the current state. I also create
                    //"non" conditional versions of those so that if Alice force closes I can react
                    //properly.

                    //prepare to give Alice her money if this is the latest state
                    //or prepare to sweep it from her if this is not the latest state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                    //actually give Alice her money if this is the latest state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                    new_from_revo_tx_1.vin[ 0 ].witness = [ bobs_conditional_revo_tx_1_sig, alices_conditional_revo_tx_1_sig, alices_first_revo_script, cblock ];

                    //sweep Alice's money if she tries to broadcast old state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                    new_from_revo_tx_2.vin[ 0 ].witness = [ bobs_conditional_revo_tx_2_sig, alices_conditional_revo_tx_2_sig, alices_second_revo_script, cblock ];

                    //prepare to restore the current state if the sender did not pay bob
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];

                    //actually restore the current state if the sender did not pay bob
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: revo_tree, target: second_revo_target });
                    new_restore_from_revo_tx.vin[ 0 ].witness = [ bobs_conditional_restoration_sig, alices_conditional_restoration_sig, second_revo_script, cblock ];

                    //the unconditional versions of all the above -- in case Alice force closes
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    first_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                    from_revo_tx_1.vin[ 0 ].witness = [ bobs_revo_tx_1_sig, alices_revo_tx_1_sig, alices_first_revo_script, cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                    from_revo_tx_2.vin[ 0 ].witness = [ bobs_revo_tx_2_sig, alices_revo_tx_2_sig, alices_second_revo_script, cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: revo_tree, target: second_revo_target });
                    restore_from_revo_tx.vin[ 0 ].witness = [ bobs_restoration_sig, alices_restoration_sig, second_revo_script, cblock ];

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "bob",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage,
                        htlc_hash,
                        force_close_tx: prev_force_close_tx,
                        conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                        conditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_from_revo_tx_1 ).hex,
                        conditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( new_from_revo_tx_2 ).hex,
                        conditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        conditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_restore_from_revo_tx ).hex,
                        unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                        unconditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( from_revo_tx_1 ).hex,
                        unconditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( from_revo_tx_2 ).hex,
                        unconditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                        unconditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( restore_from_revo_tx ).hex,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        when_to_restore_current_state: 20, //short because I don't want to support hodl invoices yet
                        //note that the timeout_tx is there in case your counterparty disappears after you
                        //force close -- Bob can EITHER sweep the money using the timeout tx after 4032
                        //blocks, if Alice disappears entirely, or -- if he force closes and then Alice at
                        //least sticks around long enough to move the money into the htlc, but then doesn't
                        //disclose the preimage within 20 blocks, Bob can restore the existing state using
                        //the new_second_from_htlc_tx and the restoration_tx
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                        time_til_timeout_tx: 4032,
                    }

                    console.log( 73, hedgehog.state[ chan_id ].balances_before_most_recent_send );
                    console.log( 74, hedgehog.state[ chan_id ].balances );

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Alice can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Bob's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    console.log( 'htlc sent!' );
                    console.log( 75, hedgehog.state[ chan_id ].balances );

                    if ( invoice ) {
                        //start listening for the invoice to be paid
                        var loop = async () => {
                            //TODO: if the invoice is not paid quickly and Alice won't cancel it, force close
                            console.log( 'checking invoice status' );
                            var delay_tolerance = 10;
                            var nwc_info = nwcjs.processNWCstring( nwc_string );
                            var invoice_status_info = await nwcjs.checkInvoice( nwc_info, invoice, delay_tolerance );
                            if ( invoice_status_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "result_type" in invoice_status_info && invoice_status_info[ "result_type" ] !== "lookup_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "error" in invoice_status_info && invoice_status_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_status_info[ "error" ] )} -- please try again` );
                            if ( invoice_status_info.result.settled_at ) {
                                var sigs_and_stuff = await hedgehog.checkIfOutgoingHTLCIsSettled( chan_id, invoice_status_info.result.preimage );
                                var msg = JSON.stringify({
                                    type: "payment_complete",
                                    msg: {
                                        chan_id,
                                        preimage: invoice_status_info.result.preimage,
                                        sigs_and_stuff,
                                    }
                                });
                                var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                                var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                                super_nostr.sendEvent( event, socket );
                                return;
                            }
                            await super_nostr.waitSomeSeconds( loop_delay );
                            return loop();
                            //return here
                            //TODO: resolve the htlc
                        }
                        await loop();
                    }

                    //TODO: set up some kind of listener to do the rest, e.g. getting a preimage
                    //from the recipient (if they have it) or from the nwc funding source and
                    //using it to close out the posititon with the sender (and the recipient, if
                    //they don't already have the preimage) and then revoking the
                    //revocation_address so that it can't be used
                },
                aliceReceivesHTLC: async data => {
                    //TODO: ensure Alice rejects the offer if it contains an htlc_hash she doesn't expect
                    //-- namely, one from a lightning invoice Bob offered to pay her with -- and she
                    //should also reject it if the amount in the invoice she is expecting does not match
                    //the amount offered to her by this htlc -- oh yeah and I just figured out that she
                    //should also *independently* have info from the sender about how much they want to
                    //pay her, that way Bob can't send her an invoice for *less* than that and keep the
                    //difference -- then again, she is the one who hit receive, and then typed in an
                    //amount, so she *should* know how much money to expect
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];
                    var secret_for_responding_to_bob = null;
                    var invoice = null;
                    if ( data[ "secret" ] ) secret_for_responding_to_bob = data[ "secret" ];
                    if ( data[ "invoice" ] ) invoice = data[ "invoice" ];

                    if ( Object.keys( hedgehog.state[ chan_id ].pending_htlc ).length ) return alert( `you have a pending htlc, and you cannot receive money in this channel while you have one...clear it before proceeding` );

                    var amnt = data[ "amnt" ];
                    if ( amnt < 330 ) return alert( `the dust limit is 330 sats and this htlc is worth only ${amnt} sats so we reject it` );
                    if ( amnt > hedgehog.state[ chan_id ].balances[ 1 ] ) return alert( `bob tried to send you more money than he has so we reject it` );

                    //give Bob a revocation hash
                    var alices_revocation_preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    var alices_revocation_hash = await hedgehog.sha256( hedgehog.hexToBytes( alices_revocation_preimage ) );
                    if ( secret_for_responding_to_bob ) {
                        var recipient = $_GET[ "layer2" ];
                        var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                        var nostr_privkey = l2generator.state.depositor_data[ depositor_id ].nostr_privkey;
                        var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                        var socket = super_nostr.sockets[ socket_id ].socket;
                        var secret_for_responding_to_alice = super_nostr.getPrivkey();
                        var msg = JSON.stringify({
                            type: "secret_you_need",
                            msg: {
                                thing_needed: JSON.stringify({
                                    alices_revocation_hash,
                                    secret_for_responding_to_alice,
                                }),
                                secret: secret_for_responding_to_bob,
                            }
                        });
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                        var preparsed_info_from_bob = await getNote( secret_for_responding_to_alice );
                        sessionStorage.removeItem( secret_for_responding_to_alice );
                        var data = JSON.parse( preparsed_info_from_bob )[ "data" ];
                        var secret_2_for_responding_to_bob = JSON.parse( preparsed_info_from_bob )[ "secret_2_for_responding_to_bob" ];
                    } else {
                        console.log( JSON.stringify({alices_revocation_hash}) );
                        alert( `send your counterparty the data in your console and then click ok` );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter the data from your counterparty here` ) );
                    }
                    var new_amnt = data[ "amnt" ];
                    if ( new_amnt !== amnt ) return alert( `aborting because your counterparty tried to scam you on the amount` );
                    var new_chan_id = data[ "chan_id" ];
                    if ( new_chan_id !== chan_id ) return alert( `aborting because your counterparty tried to scam you with an invalid chan_id` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( amnt <= hedgehog.state[ chan_id ].balances[ 1 ] - hedgehog.state[ chan_id ].balances_before_most_recent_receive[ 1 ] ) return alert( `aborting because your counterparty tried to send you a negative amount -- it may not look like it, but, since you were the last person to receive, if they want to send you *more* money they ought to take whatever amount they previously sent you, add the new amount to that, and then add the *sum* to whatever amount you had before they most recently sent you money -- and *that's* what they should send you.` );
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create the htlc
                    var htlc_hash = data[ "htlc_hash" ];
                    if ( invoice ) {
                        var invoice_hash = hedgehog.getInvoicePmthash( invoice );
                        if ( htlc_hash !== invoice_hash ) return alert( `bob tried to scam you by giving you an htlc unrelated to the invoice` );
                        var invoice_amt = hedgehog.getInvoiceAmount( invoice );
                        //TODO: consider whether to allow the invoice to pay you less
                        //as a kind of fee for Bob
                        if ( invoice_amt !== data[ "amnt" ] ) return alert( `bob tried to scam you by giving you an invoice with the wrong amount` );
                    }
                    var htlc_scripts = hedgehog.makeHTLC( chan_id, htlc_hash );
                    var htlc_address = hedgehog.makeAddress( htlc_scripts );

                    //create tx1 to send all the funds into the htlc
                    var tx1 = tapscript.Tx.create({
                        //TODO: there's no sequence number because this is expected to be used
                        //when Alice is receiving a lightning payment, and the htlc will have
                        //a timelock of 20 blocks, 20 because every hop on an LN path increases
                        //the timelock and most wallets have a max timelock of only 2016 blocks
                        //-- but, to ensure Alice isn't screwed if she goes offline for 20
                        //blocks, we'll make it so that, after the 20 blocks expire, Bob can
                        //only sweep the funds into a revocable address that *does* have a
                        //2016 block timelock before he can sweep them from *there* -- and then,
                        //when updating the state, Bob will revoke his ability to withdraw from
                        //the revocable address
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                    });
                    var tx1_txid = tapscript.Tx.util.getTxid( tx1 );

                    //create an address that Alice can revoke later -- I will reuse
                    //makeHTLC for this because she can revoke this one by revealing
                    //its preimage after signing a tx that lets Bob sweep it if he
                    //learns the preimage
                    var alices_revocation_scripts = hedgehog.makeHTLC( chan_id, alices_revocation_hash );
                    var alices_revocation_address = hedgehog.makeAddress( alices_revocation_scripts );

                    //create first_from_htlc_tx to disperse the funds from the htlc to Alice's
                    //revocation_address if Alice discloses her knowledge of the payment preimage
                    var first_from_htlc_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                            hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                        ],
                    });
                    var first_from_htlc_txid = tapscript.Tx.util.getTxid( first_from_htlc_tx );

                    //note that this revocation path requires Alice to disclose alices_revocation_preimage
                    //which means it uses the first path in alices_revocation_scripts
                    //she should only do this once the new state has been created
                    //if Alice revokes this state the following tx lets Bob sweep the funds
                    var from_revo_tx_1 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                        vout: [
                            hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                        ],
                    });

                    //this one actually disperses the funds to Alice but only after a 20 block timelock
                    //it also uses the second path in alices_revocation_scripts
                    var from_revo_tx_2 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                        vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                    });

                    //create an address that Bob can revoke later -- I will reuse
                    //makeHTLC for this because he can revoke this one by revealing
                    //its preimage after signing a tx that lets Alice sweep it if
                    //she learns the preimage
                    var revocation_hash = data[ "revocation_hash" ];
                    var revocation_scripts = hedgehog.makeHTLC( chan_id, revocation_hash );
                    var revocation_address = hedgehog.makeAddress( revocation_scripts );

                    //create second_from_htlc_tx to move the funds into the revocation addy after a 20 block
                    //timelock if Alice does not disclose her knowledge of the preimage in a timely manner
                    var second_from_htlc_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 20
                        vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                    });
                    var htlc_2_txid = tapscript.Tx.util.getTxid( second_from_htlc_tx );

                    //create restore_from_revo_tx to disperse the funds from the revocation address to
                    //restore the current state if Bob did not revoke this address (for use when Alice
                    //won't disclose the preimage in the "happy path" so he forces her to do so or go
                    //back to the prior state, or, if he tries to do this just because he thinks she will
                    //be offline for 20 blocks, she gets 2016 blocks to show he revoked this path and
                    //penalize him)
                    //TODO: ensure Alice cannot put the money in the revocation address after Bob revokes
                    //it -- note that I thought for a second Alice could broadcast the *prior* state and
                    //thus force Bob to "update" the state to the one where the money is in the htlc, from
                    //which he is screwed because he can only move it from there to the state where Alice
                    //gets the new state as of this state update, or into the revocation address; but that
                    //is not true for two reasons: first, Alice will revoke that state shortly, so she
                    //cannot do that; and even if she didn't, Alice can only force closes into the state
                    //when she last sent money, in which case she loses the money she gains through this
                    //transaction -- so Bob can just let her lose that money.
                    //And I don't think Alice has any other opportunity to put the money in the revocation
                    //address after Bob revokes it -- he will only revoke it after they've created the
                    //new state and Alice has fully revoked this one, so if she tries to get it into the
                    //revocation address later, she will be screwed
                    var amnt_for_alice = balances[ 0 ];
                    var amnt_for_bob = balances[ 1 ] - 500 - 500 - 500 - 500;
                    var restore_from_revo_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                        vout: [],
                    });
                    if ( am_alice ) {
                        if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }

                    //create bob_tried_to_cheat_tx that lets Alice sweep the funds if
                    //Bob tries to restore the current state after revoking it
                    var bob_tried_to_cheat_tx = tapscript.Tx.create({
                        vin: [hedgehog.getVin( htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                    });

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_htlc_script = htlc_scripts[ 0 ];
                    var first_htlc_target = tapscript.Tap.encodeScript( first_htlc_script );
                    var htlc_tree = htlc_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_htlc_script = htlc_scripts[ 1 ];
                    var second_htlc_target = tapscript.Tap.encodeScript( second_htlc_script );
                    var alices_first_revo_script = alices_revocation_scripts[ 0 ];
                    var alices_first_revo_target = tapscript.Tap.encodeScript( alices_first_revo_script );
                    var alices_second_revo_script = alices_revocation_scripts[ 1 ];
                    var alices_second_revo_target = tapscript.Tap.encodeScript( alices_second_revo_script );
                    var alices_revo_tree = alices_revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var first_revo_script = revocation_scripts[ 0 ];
                    var first_revo_target = tapscript.Tap.encodeScript( first_revo_script );
                    var revo_tree = revocation_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var second_revo_script = revocation_scripts[ 1 ];
                    var second_revo_target = tapscript.Tap.encodeScript( second_revo_script );
                    var bobs_first_htlc_sig = data[ "bobs_first_htlc_sig" ];
                    var sighash_first_htlc = tapscript.Signer.taproot.hash( first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var is_valid_first_htlc = await nobleSecp256k1.schnorr.verify( bobs_first_htlc_sig, sighash_first_htlc, pubkey_to_validate_against );
                    var bobs_revo_tx_1_sig = data[ "bobs_revo_tx_1_sig" ];
                    var revo_tx_1_sighash = tapscript.Signer.taproot.hash( from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_revo_tx_1_sig, revo_tx_1_sighash, pubkey_to_validate_against );
                    var bobs_revo_tx_2_sig = data[ "bobs_revo_tx_2_sig" ];
                    var revo_tx_2_sighash = tapscript.Signer.taproot.hash( from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                    var revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_revo_tx_2_sig, revo_tx_2_sighash, pubkey_to_validate_against );
                    var bobs_second_htlc_sig = data[ "bobs_second_htlc_sig" ];
                    var sighash_second_htlc = tapscript.Signer.taproot.hash( second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var is_valid_second_htlc = await nobleSecp256k1.schnorr.verify( bobs_second_htlc_sig, sighash_second_htlc, pubkey_to_validate_against );
                    // var bobs_restoration_sig = data[ "bobs_restoration_sig" ];
                    // var sighash_restoration = tapscript.Signer.taproot.hash( restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    // var is_valid_restoration = await nobleSecp256k1.schnorr.verify( bobs_restoration_sig, sighash_restoration, pubkey_to_validate_against );
                    var bobs_cheater_sig = data[ "bobs_cheater_sig" ];
                    var sighash_cheater = tapscript.Signer.taproot.hash( bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                    var is_valid_cheater = await nobleSecp256k1.schnorr.verify( bobs_cheater_sig, sighash_cheater, pubkey_to_validate_against );

                    // if ( !is_valid_first_htlc || !is_valid_second_htlc || !is_valid_restoration || !is_valid_cheater ) {
                    if ( !is_valid_first_htlc || !is_valid_second_htlc || !is_valid_cheater ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign all of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    var alices_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                    var alices_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var alices_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                    var alices_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                    var alices_first_revo_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                    var alices_second_revo_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                    var alices_restoration_sig = tapscript.Signer.taproot.sign( privkey, restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                    var alices_cheater_sig = tapscript.Signer.taproot.sign( privkey, bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_txid = tapscript.Tx.util.getTxid( new_tx1 );
                        var new_first_from_htlc_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_tx1_txid, 0, original_amnt - 500 - 500, htlc_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt, alices_revocation_address ),
                                hedgehog.getVout( balances[ 1 ] - 500 - 500 - 500 - amnt, bobs_address ),
                            ],
                        });
                        var new_first_from_htlc_txid = tapscript.Tx.util.getTxid( new_first_from_htlc_tx );
                        var new_from_revo_tx_1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address )],
                            vout: [
                                hedgehog.getVout( balances[ 0 ] + amnt - 500, bobs_address ),
                            ],
                        });
                        var new_from_revo_tx_2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_first_from_htlc_txid, 0, balances[ 0 ] + amnt, alices_revocation_address, 20 )],
                            vout: [hedgehog.getVout( balances[ 0 ] + amnt - 500, alices_address )],
                        })
                        var new_second_from_htlc_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 20
                            vin: [hedgehog.getVin( tx1_txid, 0, original_amnt - 500 - 500, htlc_address, 5 )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500, revocation_address )],
                        });
                        var new_htlc_2_txid = tapscript.Tx.util.getTxid( new_second_from_htlc_tx );
                        var new_restore_from_revo_tx = tapscript.Tx.create({
                            //TODO: change the sequence number (relative timelock) from 5 to 2016
                            vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address, 5 )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_restore_from_revo_tx.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_bob_tried_to_cheat_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( new_htlc_2_txid, 0, original_amnt - 500 - 500 - 500, revocation_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500 - 500 - 500, alices_address )],
                        });
                        var bobs_conditional_first_htlc_sig = data[ "bobs_conditional_first_htlc_sig" ];
                        var conditional_htlc_1_sighash = tapscript.Signer.taproot.hash( new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var conditional_htlc_1_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_first_htlc_sig, conditional_htlc_1_sighash, pubkey_to_validate_against );
                        var alices_conditional_first_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_first_from_htlc_tx, 0, { extension: first_htlc_target }).hex;
                        var bobs_conditional_revo_tx_1_sig = data[ "bobs_conditional_revo_tx_1_sig" ];
                        var conditional_revo_tx_1_sighash = tapscript.Signer.taproot.hash( new_from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var conditional_revo_tx_1_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_revo_tx_1_sig, conditional_revo_tx_1_sighash, pubkey_to_validate_against );
                        var alices_conditional_revo_tx_1_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_1, 0, { extension: alices_first_revo_target }).hex;
                        var bobs_conditional_revo_tx_2_sig = data[ "bobs_conditional_revo_tx_2_sig" ];
                        var conditional_revo_tx_2_sighash = tapscript.Signer.taproot.hash( new_from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var conditional_revo_tx_2_sig_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_revo_tx_2_sig, conditional_revo_tx_2_sighash, pubkey_to_validate_against );
                        var alices_conditional_revo_tx_2_sig = tapscript.Signer.taproot.sign( privkey, from_revo_tx_2, 0, { extension: alices_second_revo_target }).hex;
                        var bobs_conditional_second_htlc_sig = data[ "bobs_conditional_second_htlc_sig" ];
                        var conditional_htlc_2_sighash = tapscript.Signer.taproot.hash( new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var conditional_htlc_2_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_second_htlc_sig, conditional_htlc_2_sighash, pubkey_to_validate_against );
                        var alices_conditional_second_htlc_sig = tapscript.Signer.taproot.sign( privkey, new_second_from_htlc_tx, 0, { extension: second_htlc_target }).hex;
                        var bobs_conditional_cheater_sig = data[ "bobs_conditional_cheater_sig" ];
                        var conditional_cheater_sighash = tapscript.Signer.taproot.hash( new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;
                        var conditional_cheater_is_valid = await nobleSecp256k1.schnorr.verify( bobs_conditional_cheater_sig, conditional_cheater_sighash, pubkey_to_validate_against );
                        var alices_conditional_restoration_sig = tapscript.Signer.taproot.sign( privkey, new_restore_from_revo_tx, 0, { extension: second_revo_target }).hex;
                        var alices_conditional_cheater_sig = tapscript.Signer.taproot.sign( privkey, new_bob_tried_to_cheat_tx, 0, { extension: first_revo_target }).hex;

                        if ( !conditional_htlc_1_is_valid || !conditional_htlc_2_is_valid || !conditional_cheater_is_valid || !conditional_revo_tx_1_sig_is_valid || !conditional_revo_tx_2_sig_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                    }

                    var data_for_bob = {
                        alices_first_htlc_sig,
                        alices_second_htlc_sig,
                        alices_restoration_sig,
                        alices_revo_tx_1_sig,
                        alices_revo_tx_2_sig,
                    }
                    if ( alices_conditional_first_htlc_sig ) data_for_bob[ "alices_conditional_first_htlc_sig" ] = alices_conditional_first_htlc_sig;
                    if ( alices_conditional_second_htlc_sig ) data_for_bob[ "alices_conditional_second_htlc_sig" ] = alices_conditional_second_htlc_sig;
                    if ( alices_conditional_restoration_sig ) data_for_bob[ "alices_conditional_restoration_sig" ] = alices_conditional_restoration_sig;
                    if ( alices_conditional_revo_tx_1_sig ) data_for_bob[ "alices_conditional_revo_tx_1_sig" ] = alices_conditional_revo_tx_1_sig;
                    if ( alices_conditional_revo_tx_2_sig ) data_for_bob[ "alices_conditional_revo_tx_2_sig" ] = alices_conditional_revo_tx_2_sig;

                    if ( secret_for_responding_to_bob ) {
                        var recipient = $_GET[ "layer2" ];
                        var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                        var nostr_privkey = l2generator.state.depositor_data[ depositor_id ].nostr_privkey;
                        var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                        var socket = super_nostr.sockets[ socket_id ].socket;
                        var secret_2_for_responding_to_alice = super_nostr.getPrivkey();
                        var msg = JSON.stringify({
                            type: "secret_you_need",
                            msg: {
                                thing_needed: JSON.stringify({
                                    data: data_for_bob,
                                    secret_2_for_responding_to_alice,
                                }),
                                secret: secret_2_for_responding_to_bob,
                            }
                        });
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                        var preparsed_info_from_bob = await getNote( secret_2_for_responding_to_alice );
                        sessionStorage.removeItem( secret_2_for_responding_to_alice );
                        var data = JSON.parse( preparsed_info_from_bob );
                    } else {
                        console.log( `send this data to bob:` );
                        console.log( JSON.stringify( data_for_bob ) );
                        alert( `send the data in your console to bob and then click ok` );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter bob's reply here` ) );
                    }

                    //validate the rest of the data sent by your counterparty

                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );

                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, htlc_address )],
                        });
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //prepare the transaction that uses the htlc to prepare to create the new state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                    first_from_htlc_tx.vin[ 0 ].witness = [ bobs_first_htlc_sig, alices_first_htlc_sig, first_htlc_script, cblock ];

                    //actually give Alice her money if this is the latest state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                    from_revo_tx_1.vin[ 0 ].witness = [ bobs_revo_tx_1_sig, alices_revo_tx_1_sig, alices_first_revo_script, cblock ];

                    //let Bob sweep Alice's money if she tries to broadcast old state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                    from_revo_tx_2.vin[ 0 ].witness = [ bobs_revo_tx_2_sig, alices_revo_tx_2_sig, alices_second_revo_script, cblock ];

                    //prepare the transaction that uses the htlc to restore the current state
                    var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                    second_from_htlc_tx.vin[ 0 ].witness = [ bobs_second_htlc_sig, alices_second_htlc_sig, second_htlc_script, cblock ];

                    //if necessary, prepare and save the full revocation transactions
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    var prev_force_close_tx = hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ];

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: first_htlc_target });
                        new_first_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_first_htlc_sig, alices_conditional_first_htlc_sig, first_htlc_script, cblock ];
                        //in case Bob force closes, prepare and save the conditional transaction that uses the htlc to actually create the new state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_first_revo_target });
                        new_from_revo_tx_1.vin[ 0 ].witness = [ bobs_conditional_revo_tx_1_sig, alices_conditional_revo_tx_1_sig, alices_first_revo_script, cblock ];
                        //let Bob conditionally sweep Alice's money if she tries to broadcast old state
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: alices_revo_tree, target: alices_second_revo_target });
                        new_from_revo_tx_2.vin[ 0 ].witness = [ bobs_conditional_revo_tx_2_sig, alices_conditional_revo_tx_2_sig, alices_second_revo_script, cblock ];
                        var [ _, cblock ] = tapscript.Tap.getPubKey( "ab".repeat( 32 ), { tree: htlc_tree, target: second_htlc_target });
                        new_second_from_htlc_tx.vin[ 0 ].witness = [ bobs_conditional_second_htlc_sig, alices_conditional_second_htlc_sig, second_htlc_script, cblock ];
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                            conditional_second_htlc_tx: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //ensure the balances_before_most_recent_send are updated to the current state
                    //so that, after the htlc gets settled, Bob can add amnt to
                    //balances_before_most_recent_send and know that's the amount to expect in
                    //Alice's next state update
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    hedgehog.state[ chan_id ].pending_htlc = {
                        from: "bob",
                        now: Math.floor( Date.now() / 1000 ),
                        amnt,
                        htlc_preimage: null,
                        htlc_hash,
                        force_close_tx: tapscript.Tx.encode( tx0 ).hex,
                        //TODO: change the value of when_to_force_close to something more reasonable
                        //than 10 blocks after the htlc is created
                        when_to_force_close: 10,
                        from_force_close_to_htlc: tapscript.Tx.encode( tx1 ).hex,
                        when_to_fund_htlc: 1996, //shorter than normal so that 4032 blocks is never exceeded
                        conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_first_from_htlc_tx ).hex,
                        conditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( new_from_revo_tx_1 ).hex,
                        conditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( new_from_revo_tx_2 ).hex,
                        conditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_second_from_htlc_tx ).hex,
                        conditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( new_restore_from_revo_tx ).hex,
                        unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state: tapscript.Tx.encode( first_from_htlc_tx ).hex,
                        unconditional_tx_to_actually_give_alice_her_money_if_latest_state: tapscript.Tx.encode( from_revo_tx_1 ).hex,
                        unconditional_tx_to_sweep_alices_money_if_not_latest_state: tapscript.Tx.encode( from_revo_tx_2 ).hex,
                        unconditional_tx_to_prepare_restoration_if_alices_counterparty_never_paid: tapscript.Tx.encode( second_from_htlc_tx ).hex,
                        unconditional_tx_to_actually_restore_if_alices_counterparty_never_paid: tapscript.Tx.encode( restore_from_revo_tx ).hex,
                        when_to_restore_current_state: 2026, //longer than any lightning invoice locktime
                        txid_to_watch_for: prev_txid,
                        replacement_tx1_if_txid_to_watch_for_is_seen: tapscript.Tx.encode( new_tx1 ).hex,
                        //remember to decode the following tx, then make the preimage the item in
                        //the witness stack closest to the script, then reencode it, then broadcast it
                        channels_with_pending_outgoing_htlcs_linked_to_this_one: {},
                        time_when_preimage_was_received: null,
                        time_to_wait_after_preimage_is_received: 2016,
                    }

                    //test the following scenarios:

                    //alice force closes and restores the current state
                    console.log( `first test tx0 (alice) tx1 (alice) second_from_htlc_tx (alice)` );
                    //bob force closes and alice restores the current state
                    console.log( `next test prev_tx0 (bob) replacement_tx1 (alice) new_second_from_htlc_tx (alice)` );
                    //alice force closes and gives herself the money using a preimage obtained from bob
                    console.log( `next test tx0 (alice) tx1 (alice) first_from_htlc_tx (alice)` );
                    //bob force closes and alice gives herself the money using a preimage obtained from bob
                    console.log( `next test prev_tx0 (bob) replacement_tx1 (alice) new_first_from_htlc_tx (alice)` );

                    //TODO: also test other scenarios and consider eliminating txs that Alice doesn't need
                    //TODO: relatedly, I think Bob also has txs that he doesn't need -- and in both cases
                    //I think these unneeded txs allow them to put the money in states that they shouldn't
                    //be able to put them in, because they can steal them from those states in some scenarios
                    //e.g. Bob shouldn't be able to put Alice's money in a state she has revoked unless *she*
                    //broadcasts it after revoking it -- when *Bob* force closes he should not be able to do
                    //that

                    //TODO: set up a listener to get the preimage from somewhere
                    //or restore the old state after too much time goes by without resolution

                    //i am alice

                    if ( invoice ) return invoice;
                    return true;
                },
                closeChannel: chan_id => {
                    console.log( "Broadcast this transaction to initiate a force closure:" );
                    console.log( hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ] );
                    //TODO: change the 5 to a 2016
                    console.log( "Wait 5 blocks and broadcast this transaction to finalize the force closure:" );
                    console.log( hedgehog.state[ chan_id ].latest_force_close_txs[ 1 ] );
                    return [ hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ], hedgehog.state[ chan_id ].latest_force_close_txs[ 1 ] ];
                },
                checkIfIncomingHTLCIsSettled: async data => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //check if this channel has a pending htlc
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    if ( !Object.keys( pending_htlc ).length ) return;

                    if ( am_alice && pending_htlc.from === "alice" ) return;
                    if ( !am_alice && pending_htlc.from !== "alice" ) return;

                    if ( !hedgehog.state[ chan_id ].pending_htlc.htlc_preimage ) {
                        var data_for_counterparty = {
                            msg: "unsettled",
                            htlc_hash: hedgehog.state[ chan_id ].pending_htlc.htlc_hash,
                        }
                        console.log( JSON.stringify( data_for_counterparty ) );
                        return alert( 'send the data in your console to your counterparty' );
                    }
                    var data_for_counterparty = {
                        status: "settled",
                        htlc_preimage: hedgehog.state[ chan_id ].pending_htlc.htlc_preimage,
                    }
                    console.log( JSON.stringify( data_for_counterparty ) );
                    alert( 'send the data in your console to your counterparty and then click ok' );
                    await hedgehog.waitSomeSeconds( 1 );
                    var data = JSON.parse( prompt( `enter your counterparty's reply here` ) );
                    var amnt_expected = hedgehog.state[ chan_id ].balances[ 1 ] + hedgehog.state[ chan_id ].pending_htlc.amnt;
                    if ( data[ "amnt" ] !== amnt_expected ) return alert( `something strange happened, your counterparty tried to send ${data[ "amnt" ]} and you expected ${amnt_expected} -- force close and settle with the preimage` );
                    var skip_pending_check = true;
                    hedgehog.receive( data, skip_pending_check );
                    hedgehog.state[ chan_id ].pending_htlc = {}
                },
                checkIfOutgoingHTLCIsSettled: async ( chan_id, preimage ) => {
                    if ( !chan_id ) chan_id = prompt( `enter chan_id` );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    if ( !preimage ) {
                        console.log( JSON.stringify( {
                            chan_id,
                        } ) );
                        alert( 'send the data in your console to your counterparty and then click ok -- btw they should run hedgehog.checkIfIncomingHTLCIsSettled()' );
                        await hedgehog.waitSomeSeconds( 1 );
                        var data = JSON.parse( prompt( `enter bob's reply here` ) );
                        if ( data[ "status" ] === "unsettled" ) return alert( 'not settled yet' );
                        preimage = data[ "htlc_preimage" ];
                    }
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    var expected_hash = pending_htlc.htlc_hash;
                    //ensure hashing the preimage won't crash the pc
                    var is_hex = hedgehog.isValidHex( preimage );
                    var is_right_size = preimage.length === 64;
                    if ( is_hex && is_right_size ) {
                        var actual_hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                        if ( expected_hash !== actual_hash ) return;
                    }
                    if ( am_alice ) var amnt_to_send = hedgehog.state[ chan_id ].balances_before_most_recent_send[ 1 ] + pending_htlc[ "amnt" ];
                    else var amnt_to_send = hedgehog.state[ chan_id ].balances_before_most_recent_send[ 0 ] + pending_htlc[ "amnt" ];
                    var skip_pending_check = true;
                    console.log( 75.5, hedgehog.state[ chan_id ].balances_before_most_recent_send );
                    console.log( 75.6, pending_htlc[ "amnt" ] );
                    console.log( 76, hedgehog.state[ chan_id ].balances );
                    console.log( amnt_to_send );
                    var sigs_and_stuff = hedgehog.send( chan_id, amnt_to_send, null, skip_pending_check );
                    console.log( 77, hedgehog.state[ chan_id ].balances );
                    // console.log( "send this data to your counterparty:" );
                    // console.log( JSON.stringify( sigs_and_stuff ) );
                    hedgehog.state[ chan_id ].pending_htlc = {}
                    return sigs_and_stuff;
                },
                settleIncomingHTLC: async data => {
                    console.log( 0 );
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];
                    var preimage = data[ "preimage" ];

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //check if this channel has a pending htlc
                    var pending_htlc = hedgehog.state[ chan_id ].pending_htlc;
                    if ( !Object.keys( pending_htlc ).length ) return;

                    if ( am_alice && pending_htlc.from === "alice" ) return;
                    console.log( 0.5 );
                    if ( !am_alice && pending_htlc.from !== "alice" ) return;

                    console.log( 1 );

                    var expected_hash = pending_htlc.htlc_hash;
                    //ensure hashing the preimage won't crash the pc
                    var is_hex = hedgehog.isValidHex( preimage );
                    var is_right_size = preimage.length === 64;
                    if ( is_hex && is_right_size ) {
                        var actual_hash = await hedgehog.sha256( hedgehog.hexToBytes( preimage ) );
                        console.log( 1.5, expected_hash, actual_hash );
                        if ( expected_hash !== actual_hash ) return alert( `error regarding the hashes: expected_hash ${expected_hash} but got ${actual_hash} instead -- the preimage was ${preimage}` );
                    } else {
                        console.log( 'force close this channel and restore the previous state, and if it is linked to any related payments, force close those too and restore *their* previous state' );
                        console.log( 'broadcast this force close tx:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.force_close_tx );
                        console.log( 'then wait 1996 blocks and broadcast this tx that funds the htlc:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.from_force_close_to_htlc );
                        console.log( 'then wait 2016 blocks and broadcast this to restore the prior state:' );
                        console.log( hedgehog.state[ chan_id ].pending_htlc.restore_current_state_after_force_close );
                    }
                    console.log( 2 );

                    //mark htlc ready for resolution

                    hedgehog.state[ chan_id ].pending_htlc[ "htlc_preimage" ] = preimage;
                    hedgehog.state[ chan_id ].pending_htlc[ "time_when_preimage_was_received" ] = Math.floor( Date.now() / 1000 );

                    //add the preimage to the transactions that need it

                    var first_tx_to_fix = hedgehog.state[ chan_id ].pending_htlc.unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state;
                    var decoded_1 = tapscript.Tx.decode( first_tx_to_fix );
                    decoded_1.vin[ 0 ].witness = [ decoded_1.vin[ 0 ].witness[ 0 ], decoded_1.vin[ 0 ].witness[ 1 ], preimage, decoded_1.vin[ 0 ].witness[ 2 ], decoded_1.vin[ 0 ].witness[ 3 ] ];
                    var encoded_1 = tapscript.Tx.encode( decoded_1 ).hex;

                    console.log( 3 );

                    var second_tx_to_fix = hedgehog.state[ chan_id ].pending_htlc.conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state;
                    var decoded_2 = tapscript.Tx.decode( second_tx_to_fix );
                    decoded_2.vin[ 0 ].witness = [ decoded_2.vin[ 0 ].witness[ 0 ], decoded_2.vin[ 0 ].witness[ 1 ], preimage, decoded_2.vin[ 0 ].witness[ 2 ], decoded_2.vin[ 0 ].witness[ 3 ] ];
                    var encoded_2 = tapscript.Tx.encode( decoded_2 ).hex;

                    //save those transactions
                    hedgehog.state[ chan_id ].pending_htlc.unconditional_tx_to_prepare_to_give_alice_her_money_if_latest_state = encoded_1;
                    hedgehog.state[ chan_id ].pending_htlc.conditional_tx_to_prepare_to_give_alice_her_money_if_latest_state = encoded_2;

                    console.log( 4 );

                    //TODO: set up a listener so that if 2016 blocks go by we force close
                    return `that went well, now your counterparty should run hedgehog.checkIfOutgoingHTLCIsSettled("${chan_id}")`;
                },
            }
        </script>
        <script>
            // dependencies:
            // https://bundle.run/noble-secp256k1@1.2.14
            var super_nostr = {
                sockets: {},
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                base64ToBytes: str => {
                    var raw = atob( str );
                    var result = [];
                    var i; for ( i=0; i<raw.length; i++ ) result.push( raw.charCodeAt( i ) );
                    return new Uint8Array( result );
                },
                base64ToHex: str => {
                    var raw = atob( str );
                    var result = '';
                    var i; for ( i=0; i<raw.length; i++ ) {
                        var hex = raw.charCodeAt( i ).toString( 16 );
                        result += hex.length % 2 ? '0' + hex : hex;
                    }
                    return result.toLowerCase();
                },
                hexToBase64: hex => btoa( hex.match( /\w{2}/g ).map( a => String.fromCharCode( parseInt( a, 16 ) ) ).join( "" ) ),
                getPrivkey: () => super_nostr.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ),
                getPubkey: privkey => nobleSecp256k1.getPublicKey( privkey, true ).substring( 2 ),
                sha256: async text_or_bytes => {if ( typeof text_or_bytes === "string" ) text_or_bytes = ( new TextEncoder().encode( text_or_bytes ) );return super_nostr.bytesToHex( await nobleSecp256k1.utils.sha256( text_or_bytes ) )},
                waitSomeSeconds: num => {
                    var num = num.toString() + "000";
                    num = Number( num );
                    return new Promise( resolve => setTimeout( resolve, num ) );
                },
                getEvents: async ( relay_or_socket, ids, authors, kinds, until, since, limit, etags, ptags ) => {
                    var socket_is_permanent = false;
                    if ( typeof relay_or_socket !== "string" ) socket_is_permanent = true;
                    if ( typeof relay_or_socket === "string" ) var socket = new WebSocket( relay_or_socket );
                    else var socket = relay_or_socket;
                    var events = [];
                    var opened = false;
                    if ( socket_is_permanent ) {
                        var subId = super_nostr.getPrivkey().substring( 0, 16 );
                        var filter  = {}
                        if ( ids ) filter.ids = ids;
                        if ( authors ) filter.authors = authors;
                        if ( kinds ) filter.kinds = kinds;
                        if ( until ) filter.until = until;
                        if ( since ) filter.since = since;
                        if ( limit ) filter.limit = limit;
                        if ( etags ) filter[ "#e" ] = etags;
                        if ( ptags ) filter[ "#p" ] = ptags;
                        var subscription = [ "REQ", subId, filter ];
                        socket.send( JSON.stringify( subscription ) );
                        return;
                    }
                    socket.addEventListener( 'message', async function( message ) {
                        var [ type, subId, event ] = JSON.parse( message.data );
                        var { kind, content } = event || {}
                        if ( !event || event === true ) return;
                        events.push( event );
                    });
                    socket.addEventListener( 'open', async function( e ) {
                        opened = true;
                        var subId = super_nostr.getPrivkey().substring( 0, 16 );
                        var filter  = {}
                        if ( ids ) filter.ids = ids;
                        if ( authors ) filter.authors = authors;
                        if ( kinds ) filter.kinds = kinds;
                        if ( until ) filter.until = until;
                        if ( since ) filter.since = since;
                        if ( limit ) filter.limit = limit;
                        if ( etags ) filter[ "#e" ] = etags;
                        if ( ptags ) filter[ "#p" ] = ptags;
                        var subscription = [ "REQ", subId, filter ];
                        socket.send( JSON.stringify( subscription ) );
                    });
                    var loop = async () => {
                        if ( !opened ) {
                            await super_nostr.waitSomeSeconds( 1 );
                            return await loop();
                        }
                        var len = events.length;
                        await super_nostr.waitSomeSeconds( 1 );
                        if ( len !== events.length ) return await loop();
                        socket.close();
                        return events;
                    }
                    return await loop();
                },
                prepEvent: async ( privkey, msg, kind, tags ) => {
                    pubkey = super_nostr.getPubkey( privkey );
                    if ( !tags ) tags = [];
                    var event = {
                        "content": msg,
                        "created_at": Math.floor( Date.now() / 1000 ),
                        "kind": kind,
                        "tags": tags,
                        "pubkey": pubkey,
                    }
                    var signedEvent = await super_nostr.getSignedEvent( event, privkey );
                    return signedEvent;
                },
                sendEvent: ( event, relay_or_socket ) => {
                    var socket_is_permanent = false;
                    if ( typeof relay_or_socket !== "string" ) socket_is_permanent = true;
                    if ( typeof relay_or_socket === "string" ) var socket = new WebSocket( relay_or_socket );
                    else var socket = relay_or_socket;
                    if ( !socket_is_permanent ) {
                        socket.addEventListener( 'open', async () => {
                            socket.send( JSON.stringify( [ "EVENT", event ] ) );
                            setTimeout( () => {socket.close();}, 1000 );
                        });
                    } else {
                        socket.send( JSON.stringify( [ "EVENT", event ] ) );
                    }
                    return event.id;
                },
                getSignedEvent: async ( event, privkey ) => {
                    var eventData = JSON.stringify([
                        0,
                        event['pubkey'],
                        event['created_at'],
                        event['kind'],
                        event['tags'],
                        event['content'],
                    ]);
                    event.id = await super_nostr.sha256( eventData );
                    event.sig = await nobleSecp256k1.schnorr.sign( event.id, privkey );
                    return event;
                },
                encrypt: async ( privkey, pubkey, text ) => {
                    var msg = ( new TextEncoder() ).encode( text );
                    var iv = window.crypto.getRandomValues( new Uint8Array( 16 ) );
                    var key_raw = super_nostr.hexToBytes( nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 ) );
                    var key = await window.crypto.subtle.importKey(
                        "raw",
                        key_raw,
                        "AES-CBC",
                        false,
                        [ "encrypt", "decrypt" ],
                    );
                    var emsg = await window.crypto.subtle.encrypt(
                        {
                            name: "AES-CBC",
                            iv,
                        },
                        key,
                        msg,
                    )
                    emsg = new Uint8Array( emsg );
                    var arr = emsg;
                    emsg = super_nostr.hexToBase64( super_nostr.bytesToHex( emsg ) ) + "?iv=" + btoa( String.fromCharCode.apply( null, iv ) );
                    return emsg;
                },
                decrypt: async ( privkey, pubkey, ciphertext ) => {
                    var [ emsg, iv ] = ciphertext.split( "?iv=" );
                    var key_raw = super_nostr.hexToBytes( nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 ) );
                    var key = await window.crypto.subtle.importKey(
                        "raw",
                        key_raw,
                        "AES-CBC",
                        false,
                        [ "encrypt", "decrypt" ],
                    );
                    var decrypted = await window.crypto.subtle.decrypt(
                        {
                            name: "AES-CBC",
                            iv: super_nostr.base64ToBytes( iv ),
                        },
                        key,
                        super_nostr.base64ToBytes( emsg ),
                    );

                    var msg = ( new TextDecoder() ).decode( decrypted );
                    return msg;
                },
                newPermanentConnection: ( relay, listenFunction, handleFunction ) => {
                    var socket_id = super_nostr.getPrivkey().substring( 0, 16 );
                    super_nostr.sockets[ socket_id ] = {socket: null, connection_failure: false}
                    super_nostr.connectionLoop( 0, relay, socket_id, listenFunction, handleFunction );
                    return socket_id;
                },
                connectionLoop: async ( tries = 0, relay, socket_id, listenFunction, handleFunction ) => {
                    var socketRetrieverFunction = socket_id => {
                        return super_nostr.sockets[ socket_id ][ "socket" ];
                    }
                    var socketReplacerFunction = ( socket_id, socket ) => {
                        super_nostr.sockets[ socket_id ][ "socket" ] = socket;
                        super_nostr.sockets[ socket_id ][ "connection_failure" ] = false;
                    }
                    var socketFailureCheckerFunction = socket_id => {
                        return super_nostr.sockets[ socket_id ][ "connection_failure" ];
                    }
                    var socketFailureSetterFunction = socket_id => {
                        return super_nostr.sockets[ socket_id ][ "connection_failure" ] = true;
                    }
                    if ( socketFailureCheckerFunction( socket_id ) ) return alert( `your connection to nostr failed and could not be restarted, please refresh the page` );
                    var socket = socketRetrieverFunction( socket_id );
                    if ( !socket ) {
                        var socket = new WebSocket( relay );
                        socket.addEventListener( 'message', handleFunction );
                        socket.addEventListener( 'open', ()=>{listenFunction( socket );} );
                        socketReplacerFunction( socket_id, socket );
                    }
                    if ( socket.readyState === 1 ) {
                        await super_nostr.waitSomeSeconds( 1 );
                        return super_nostr.connectionLoop( 0, relay, socket_id, listenFunction, handleFunction );
                    }
                    // if there is no connection, check if we are still connecting
                    // give it two chances to connect if so
                    if ( socket.readyState === 0 && !tries ) {
                        await super_nostr.waitSomeSeconds( 1 );
                        return super_nostr.connectionLoop( 1, relay, socket_id, listenFunction, handleFunction );
                    }
                    if ( socket.readyState === 0 && tries ) {
                        socketFailureSetterFunction( socket_id );
                        return;
                    }
                    // otherwise, it is either closing or closed
                    // ensure it is closed, then make a new connection
                    socket.close();
                    await super_nostr.waitSomeSeconds( 1 );
                    socket = new WebSocket( relay );
                    socket.addEventListener( 'message', handleFunction );
                    socket.addEventListener( 'open', ()=>{listenFunction( socket );} );
                    socketReplacerFunction( socket_id, socket );
                    await super_nostr.connectionLoop( 0, relay, socket_id, listenFunction, handleFunction );
                }
            }
            //dependencies:
            //super_nostr
            //https://unpkg.com/@cmdcode/tapscript@1.4.0
            //https://bundle.run/noble-secp256k1@1.2.14
            var l2generator = {
                network: "testnet",
                state: {
                    l2s: {},
                    latest_addy: null,
                    utxos: {},
                    depositor_data: {},
                },
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                bigIntToHex: bigint => {return bigint.toString( 16 ).length % 2 ? "0" + bigint.toString( 16 ) : bigint.toString( 16 )},
                textToHex: text => {
                    var encoded = new TextEncoder().encode( text );
                    return Array.from( encoded )
                        .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                        .join( "" );
                },
                hexToText: hex => {
                    var bytes = new Uint8Array( Math.ceil( hex.length / 2 ) );
                    for ( var i = 0; i < hex.length; i++ ) bytes[ i ] = parseInt( hex.substr( i * 2, 2 ), 16 );
                    var text = new TextDecoder().decode( bytes );
                    return text;
                },
                pubkeyFromTaprootAddress: address => tapscript.Address.toScriptPubKey( address )[ 1 ],
                add2Pubkeys: ( pubkey1, pubkey2 ) => nobleSecp256k1.Point.fromHex( pubkey1 ).add( nobleSecp256k1.Point.fromHex( pubkey2 ) ).toHex( true ),
                shuffle: array => {
                    var currentIndex = array.length, randomIndex;
                    while ( currentIndex > 0 ) {
                        randomIndex = Math.floor( Math.random() * currentIndex );
                        currentIndex--;
                        [ array[ currentIndex ], array[ randomIndex ] ] = [
                            array[ randomIndex ], array[ currentIndex ]
                        ];
                    }
                    return array;
                },
                getData: url => {
                    return new Promise( async function( resolve, reject ) {
                        function inner_get( url ) {
                            var xhttp = new XMLHttpRequest();
                            xhttp.open( "GET", url, true );
                            xhttp.send();
                            return xhttp;
                        }
                        var data = inner_get( url );
                        data.onerror = function( e ) {
                            resolve( "error" );
                        }
                        async function isResponseReady() {
                            return new Promise( function( resolve2, reject ) {
                                if ( !data.responseText || data.readyState != 4 ) {
                                    setTimeout( async function() {
                                        var msg = await isResponseReady();
                                        resolve2( msg );
                                    }, 1 );
                                } else {
                                    resolve2( data.responseText );
                                }
                            });
                        }
                        var returnable = await isResponseReady();
                        resolve( returnable );
                    });
                },
                postData: async ( url, stringified_json, content_type = "", apikey = "" ) => {
                    var rtext = "";
                    function inner_post( url, stringified_json, content_type = "", apikey = "" ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.open( "POST", url, true );
                        if ( content_type ) {
                            xhttp.setRequestHeader( `Content-Type`, content_type );
                        }
                        if ( apikey ) {
                            xhttp.setRequestHeader( `X-Api-Key`, apikey );
                        }
                        xhttp.send( stringified_json );
                        return xhttp;
                    }
                    var data = inner_post( url, stringified_json, content_type, apikey );
                    data.onerror = function( e ) {
                        rtext = "error";
                    }
                    async function isResponseReady() {
                        return new Promise( function( resolve, reject ) {
                            if ( rtext == "error" ) {
                                resolve( rtext );
                            }
                            if ( !data.responseText || data.readyState != 4 ) {
                                setTimeout( async function() {
                                    var msg = await isResponseReady();
                                    resolve( msg );
                                }, 50 );
                            } else {
                                resolve( data.responseText );
                            }
                        });
                    }
                    var returnable = await isResponseReady();
                    return returnable;
                },
                pushBTCpmt: async rawtx => {
                    var txid = await l2generator.postData( "https://mutinynet.com/api/tx", rawtx );
                    return txid;
                },
                getBlockheight: async () => {
                    var data = await l2generator.getData( `https://mutinynet.com/api/blocks/tip/height` );
                    return Number( data );
                },
                addressOnceHadMoney: async address => {
                    var nonjson = await l2generator.getData("https://mutinynet.com/api/address/" + address);
                    var json = JSON.parse(nonjson);
                    if (json["chain_stats"]["tx_count"] > 0 || json["mempool_stats"]["tx_count"] > 0) return true;
                    return false;
                },
                loopTilAddressReceivesMoney: async address => {
                    var itReceivedMoney = false;
                    async function isDataSetYet(data_i_seek) {
                        return new Promise((resolve, reject) => {
                            if (!data_i_seek) {
                                setTimeout(async () => {
                                    console.log("waiting for address to receive money...");
                                    try {
                                        itReceivedMoney = await l2generator.addressOnceHadMoney(address);
                                    } catch (e) { }
                                    var msg = await isDataSetYet(itReceivedMoney);
                                    resolve(msg);
                                }, 2000);
                            } else {
                                resolve(data_i_seek);
                            }
                        });
                    }

                    async function getTimeoutData() {
                        var data_i_seek = await isDataSetYet(itReceivedMoney);
                        return data_i_seek;
                    }

                    let returnable = await getTimeoutData();
                    return returnable;
                },
                addressReceivedMoneyInThisTx: async address => {
                    var txid;
                    var vout;
                    var amt;
                    var nonjson = await l2generator.getData("https://mutinynet.com/api/address/" + address + "/txs");
                    var json = JSON.parse(nonjson);
                    json.forEach(tx => {
                        tx["vout"].forEach(function (output, index) {
                            if (output["scriptpubkey_address"] == address) {
                                txid = tx["txid"];
                                vout = index;
                                amt = output["value"];
                            }
                        });
                    });
                    return [txid, vout, amt];
                },
                nameL2: name => {
                    var l2_privkey = super_nostr.getPrivkey();
                    var l2id = super_nostr.getPubkey( l2_privkey );
                    l2generator.state.l2s[ l2id ] = {
                        l2_privkey,
                        name,
                        nwc_string: null,
                        claims: {},
                    }
                },
                makeUTXO: ( txid, vout, amnt, addy, skey ) => {
                    var utxo_id = l2generator.bytesToHex( nobleSecp256k1.utils.randomBytes( 8 ) );
                    l2generator.state.utxos[ utxo_id ] = {
                        txid,
                        vout,
                        amnt,
                        addy,
                        skey,
                    }
                    return utxo_id;
                },
                makeAddy: () => {
                    var skey = super_nostr.getPrivkey();
                    var pkey = super_nostr.getPubkey( skey );
                    var addy = tapscript.Address.p2tr.fromPubKey( pkey, l2generator.network );
                    l2generator.state.latest_addy = {
                        skey,
                        addy,
                    }
                },
                findUtxosWorthMore: amt => {
                    var utxo_ids = JSON.parse( JSON.stringify( Object.keys( l2generator.state.utxos ) ) );
                    utxo_ids = l2generator.shuffle( utxo_ids );
                    var utxos_to_return = [];
                    var loop = () => {
                        if ( !utxo_ids.length ) return "insufficient";
                        utxo_ids.forEach( ( utxo_id, index ) => {
                            var utxo = l2generator.state.utxos[ utxo_id ];
                            utxos_to_return.push( utxo_id );
                            utxo_ids.splice( index, 1 );
                        });
                        var sum = 0;
                        utxos_to_return.forEach( item => sum = sum + l2generator.state.utxos[ item ].amnt );
                        if ( sum >= amt ) return utxos_to_return;
                        return loop();
                    }
                    return loop();
                },
            }
        </script>
        <script>
            async function getNote( item ) {
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( sessionStorage[ item ] );
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( sessionStorage[ item ] );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                word-wrap: break-word;
                margin: 3rem 1rem;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
        </script>
    </head>
    <body>
        <div class="welcome_msg hidden">
            <h1>L2 Generator</h1>
            <p>Make your own L2 with these properties:</p>
            <ol>
                <li>anyone can deposit sats to your L2, similar to a bank</li>
                <li>your users can trade with one another cheaply and quickly</li>
                <li>unlike a bank, any user can unilaterally withdraw their sats</li>
            </ol>
            <p>Let's get started!</p>
            <p><button class="generate_l2">Generate L2</button></p>
        </div>
        <div class="name_l2 hidden">
            <p>Let's begin by naming your L2</p>
            <p><input class="l2_name"></p>
            <p><button class="submit_l2_name">Submit</button></p>
        </div>
        <div class="provider_deposit_form hidden">
            <div class="unhidden_provider_deposit_form">
                <p>Deposit sats to the following address -- this will be used to lease balanced channels to your users</p>
                <p class="provider_deposit_address"></p>
                <p class="hidden">When you've made your deposit, hit submit.</p>
                <p class="hidden"><button class="submit_provider_deposit_form">Submit</button></p>
            </div>
        </div>
        <div class="almost_done_generating_l2 hidden">
            <p>You're almost done! Just add an NWC string below with full permissions and your users will be able to interact with the lightning network</p>
            <p>NWC string</p>
            <p><input class="nwc_string"></p>
            <p><button class="submit_nwc_string">Submit</button></p>
        </div>
        <div class="show_operator_stats hidden">
            <p>Name of your L2: <span class="l2_name"></span></p>
            <p>Link to your L2: <span class="l2_link"></span></p>
            <p>Income: <span class="income">0</span> sats</p>
            <p>Expenses: <span class="expenses">0</span> sats</p>
            <p>Layer one balance: <span class="l1_balance">0</span> sats</p>
            <p>Lightning balance: <span class="ln_balance">0</span> sats</p>
        </div>
        <div class="view_l2 hidden">
            <h1 class="l2_name_to_show_depositors"></h1>
            <p>This is a bitcoin layer 2 with these properties:</p>
            <ol>
                <li>anyone can deposit sats to this L2, similar to a bank</li>
                <li>every user can trade with one another cheaply and quickly</li>
                <li>unlike a bank, any user can unilaterally withdraw their sats</li>
            </ol>
            <p>Let's get started!</p>
            <p><button class="deposit_to_l2_btn">Make a deposit</button></p>
        </div>
        <div class="deposit_to_l2 hidden">
            <p class="cost_of_deposit_invoice_loading hidden">loading...</p>
            <div class="unhidden_deposit_to_l2">
                <p>Maximum allowed deposit:</p>
                <p><span class="max_allowed_deposit">loading...</span> sats</p>
                <p>Enter whatever amount of sats you want to deposit</p>
                <p><input class="amount_to_deposit" value="10000"></p>
                <p><button class="submit_deposit_amount">Submit</button></p>
            </div>
        </div>
        <div class="pay_deposit_cost hidden">
            <p>There is a cost to deposit to this L2, to prevent spam. Please pay this invoice.</p>
            <p>Deposit cost: <span class="spam_prevention_cost"></span> sats</p>
            <p><span class="spam_prevention_invoice"></span></p>
        </div>
        <div class="make_deposit hidden">
            <p>Your cost of deposit was successfully paid, now please make your actual deposit</p>
            <p>Deposit amount: <span class="deposit_amount"></span> sats</p>
            <p><span class="deposit_invoice"></span></p>
        </div>
        <div class="wallet_home hidden">
            <p>Balance: <span class="depositor_ln_balance">loading...</span> sats</p>
            <p><button class="send">Send</button> <button class="receive">Receive</button><br><button class="force_close">Force close</button></p>
        </div>
        <script>
            var showPage = page => {
                $( '.welcome_msg' ).classList.add( "hidden" );
                $( '.provider_deposit_form' ).classList.add( "hidden" );
                $( '.almost_done_generating_l2' ).classList.add( "hidden" );
                $( '.name_l2' ).classList.add( "hidden" );
                $( '.view_l2' ).classList.add( "hidden" );
                $( '.show_operator_stats' ).classList.add( "hidden" );
                $( '.deposit_to_l2' ).classList.add( "hidden" );
                $( '.pay_deposit_cost' ).classList.add( "hidden" );
                $( '.make_deposit' ).classList.add( "hidden" );
                $( '.wallet_home' ).classList.add( "hidden" );
                $( `.${page}` ).classList.remove( "hidden" );
            }
            $( '.generate_l2' ).onclick = async () => {
                showPage( `name_l2` );
            }
            $( '.submit_l2_name' ).onclick = async () => {
                var name = $( '.l2_name' ).value;
                l2generator.nameL2( name );
                showPage( `provider_deposit_form` );
                await super_nostr.waitSomeSeconds( 1 );
                $( '.submit_provider_deposit_form' ).click();
            }
            var showProviderDepositAddress = () => {
                if ( !l2generator.state.latest_addy ) l2generator.makeAddy();
                var addy = l2generator.state.latest_addy[ "addy" ];
                $( '.provider_deposit_address' ).innerText = addy;
            }
            $( '.submit_provider_deposit_form' ).onclick = async () => {
                var addy = $( '.provider_deposit_address' ).innerText;
                await l2generator.loopTilAddressReceivesMoney( addy );
                await super_nostr.waitSomeSeconds(2);
                var txinfo = await l2generator.addressReceivedMoneyInThisTx( addy );
                var txid = txinfo[0];
                var vout = txinfo[1];
                var amnt = txinfo[2];
                // var txid = $( '.provider_deposit_txid' ).value;
                // var vout = Number( $( '.provider_deposit_vout' ).value );
                // var amnt = Number( $( '.provider_deposit_amnt' ).value );
                l2generator.makeUTXO( txid, vout, amnt, l2generator.state.latest_addy[ "addy" ], l2generator.state.latest_addy[ "skey" ] );
                showPage( `almost_done_generating_l2` );
            }
            $( '.submit_nwc_string' ).onclick = () => {
                var l2id = Object.keys( l2generator.state.l2s )[ 0 ];
                var l2 = l2generator.state.l2s[ l2id ];
                var nwc_string = $( '.nwc_string' ).value;
                l2.nwc_string = nwc_string;
                var name = l2generator.textToHex( l2.name );
                var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `?layer2=${l2id}&name=${name}`;
                $( '.show_operator_stats .l2_name' ).innerText = l2.name;
                $( '.show_operator_stats .l2_link' ).innerText = url;
                operatorInit();
                showPage( `show_operator_stats` );
            }
            if ( $_GET[ "layer2" ] && $_GET[ "name" ] ) {
                var name = l2generator.hexToText( $_GET[ "name" ] );
                showPage( 'view_l2' );
                $( '.l2_name_to_show_depositors' ).innerText = `Welcome to ` + name;
                window.onload = () => {depositorInit();}
            } else {
                showPage( `welcome_msg` );
                showProviderDepositAddress();
            }
            $( '.deposit_to_l2_btn' ).onclick = async () => {
                showPage( 'deposit_to_l2' );
            }
            var operatorStatsLoop = async () => {
                try {
                    var utxos = l2generator.state.utxos;
                    var utxo_sum = 0;
                    Object.keys( utxos ).forEach( utxo_id => utxo_sum = utxo_sum + utxos[ utxo_id ][ "amnt" ] );
                    $( '.l1_balance' ).innerText = utxo_sum;
                    var l2_id = Object.keys( l2generator.state.l2s )[ 0 ];
                    var nwc_string = l2generator.state.l2s[ l2_id ].nwc_string;
                    var nwc_info = nwcjs.processNWCstring( nwc_string );
                    var delay_tolerance = 10;
                    var nwc_balance_info = await nwcjs.getBalance( nwc_info, delay_tolerance );
                    console.log( nwc_balance_info );
                    var nwc_balance = Math.floor( nwc_balance_info.result.balance / 1000 );
                    $( '.ln_balance' ).innerText = nwc_balance;
                } catch ( e ) {}
                await hedgehog.waitSomeSeconds( loop_delay );
                operatorStatsLoop();
            }
            var operatorInit = async () => {
                var handled_messages = [];
                var l2id = Object.keys( l2generator.state.l2s )[ 0 ];
                var l2 = l2generator.state.l2s[ l2id ];
                var nostr_privkey = l2.l2_privkey;
                var nostr_pubkey = l2id;
                var relay = "wss://nostrue.com";
                var listen = async ( socket ) => {
                    var subId = super_nostr.bytesToHex( crypto.getRandomValues( new Uint8Array( 8 ) ) );
                    var filter  = {}
                    filter.kinds = [ 4 ];
                    filter[ "#p" ] = [ nostr_pubkey ];
                    filter.since = Math.floor( Date.now() / 1000 );
                    var subscription = [ "REQ", subId, filter ];
                    socket.send( JSON.stringify( subscription ) );
                }
                var handleEvent = async message => {
                    var [ type, subId, event ] = JSON.parse( message.data );
                    if ( !event || event === true ) return;
                    if ( handled_messages.includes( event.id ) ) return;
                    handled_messages.push( event.id );
                    if ( event.kind === 4 ) event.content = await super_nostr.decrypt( nostr_privkey, event.pubkey, event.content );
                    var recipient = event.pubkey;
                    var json = JSON.parse( event.content );
                    var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                    var socket = super_nostr.sockets[ socket_id ].socket;
                    var l2_id = Object.keys( l2generator.state.l2s )[ 0 ];
                    var nwc_string = l2generator.state.l2s[ l2_id ].nwc_string;
                    var nwc_info = nwcjs.processNWCstring( nwc_string );
                    console.log( json );
                    if ( json[ "type" ] === "l1_balance_query" ) {
                        var utxos = l2generator.state.utxos;
                        var utxo_sum = 0;
                        Object.keys( utxos ).forEach( utxo_id => utxo_sum = utxo_sum + utxos[ utxo_id ][ "amnt" ] );
                        //keep back 10k sats in reserve for fees
                        utxo_sum = utxo_sum - 10000;
                        if ( utxo_sum < 0 ) utxo_sum = 0;
                        var msg = JSON.stringify({
                            type: "l1_balance_query_response",
                            msg: {
                                l1_balance: utxo_sum,
                            }
                        });
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                    }
                    if ( json[ "type" ] === "i_want_to_deposit" ) {
                        var deposit_amount = Number( json.msg.deposit_amount );
                        var utxos = l2generator.state.utxos;
                        var utxo_sum = 0;
                        Object.keys( utxos ).forEach( utxo_id => utxo_sum = utxo_sum + utxos[ utxo_id ][ "amnt" ] );
                        //keep back 10k sats in reserve for fees
                        utxo_sum = utxo_sum - 10000;
                        if ( utxo_sum < 0 ) utxo_sum = 0;
                        if ( deposit_amount > utxo_sum || deposit_amount < 330 ) return console.log( 'error, deposit greater than we have or less than 330' );
                        var cost_of_deposit = 5;
                        var amnt = cost_of_deposit;
                        var desc = "depositing to L2 (paying cost)";
                        var delay_tolerance = 10;
                        var invoice_info = await nwcjs.makeInvoice( nwc_info, amnt, desc, delay_tolerance );
                        if ( invoice_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_info )}` );
                        if ( "result_type" in invoice_info && invoice_info[ "result_type" ] !== "make_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_info )}` );
                        if ( "error" in invoice_info && invoice_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_info[ "error" ] )} -- please try again` );
                        var invoice = invoice_info.result.invoice || invoice_info.result.bolt11;
                        var desc = "depositing to L2 (actual deposit)";
                        var deposit_invoice_info = await nwcjs.makeInvoice( nwc_info, deposit_amount, desc, delay_tolerance );
                        if ( deposit_invoice_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( deposit_invoice_info )}` );
                        if ( "result_type" in deposit_invoice_info && deposit_invoice_info[ "result_type" ] !== "make_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( deposit_invoice_info )}` );
                        if ( "error" in deposit_invoice_info && deposit_invoice_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( deposit_invoice_info[ "error" ] )} -- please try again` );
                        var deposit_invoice = deposit_invoice_info.result.invoice || deposit_invoice_info.result.bolt11;
                        var papa_swap_hash = hedgehog.getInvoicePmthash( deposit_invoice );
                        var utxo_ids_for_papa_swap = l2generator.findUtxosWorthMore( deposit_amount );
                        var utxos_for_papa_swap = [];
                        utxo_ids_for_papa_swap.forEach( utxo_id => utxos_for_papa_swap.push( utxos[ utxo_id ] ) );
                        var public_utxos_for_papa_swap = [];
                        utxos_for_papa_swap.forEach( utxo => {
                            public_utxos_for_papa_swap.push({
                                txid: utxo[ "txid" ],
                                vout: utxo[ "vout" ],
                                amnt: utxo[ "amnt" ],
                                addy: utxo[ "addy" ]
                            });
                        });
                        var push_all_funds_to_counterparty = true;
                        var alices_pubkey = json.msg.pubkey;
                        var alices_hash = json.msg.hash;
                        //TODO: ensure alices_pubkey_and_hash are valid
                        var alices_pubkey_and_hash = [ alices_pubkey, alices_hash ];
                        var change_address = l2generator.state.latest_addy.addy;
                        var [ chan_id, sigs_and_stuff, funding_txhex, utxos_created ] = await hedgehog.openChannel( push_all_funds_to_counterparty, alices_pubkey_and_hash, papa_swap_hash, utxos_for_papa_swap, deposit_amount, change_address );
                        var bobs_pubkey = hedgehog.state[ chan_id ].bobs_pubkey;
                        var secret = super_nostr.getPrivkey();
                        var msg = JSON.stringify({
                            type: "i_want_to_deposit_response",
                            msg: {
                                cost_of_deposit,
                                invoice,
                                deposit_invoice,
                                public_utxos_for_papa_swap,
                                change_address,
                                secret,
                                bobs_pubkey,
                            }
                        });
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                        var sig_for_papa_swap = await getNote( secret );
                        sessionStorage.removeItem( secret );

                        //prepare to validate Alice's signature

                        var multisig_script = [ alices_pubkey, "OP_CHECKSIGVERIFY", bobs_pubkey, "OP_CHECKSIG" ];
                        var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                        var multisig = hedgehog.makeAddress( [ multisig_script ] );
                        //we are using a papa swap so a transaction needs to go from the multisig to a
                        //revocable address; and a 2 week timelock from the revocable address should give
                        //the funds back to Bob; but if he revokes this path, then of course Alice can
                        //sweep it if Bob tries to use it, because she will have the revocation preimage.
                        var vin = [];
                        var sum = 0;
                        utxos_for_papa_swap.forEach( utxo => {
                            sum = sum + utxo.amnt;
                            vin.push( hedgehog.getVin( utxo.txid, utxo.vout, utxo.amnt, utxo.addy ) );
                        });
                        var papa_swap_funding_tx = tapscript.Tx.create({
                            vin,
                            vout: [hedgehog.getVout( deposit_amount, multisig )],
                        });
                        var deposit_mining_txfee = 500;
                        if ( sum - deposit_amount > 330 ) papa_swap_funding_tx.vout.push( hedgehog.getVout( sum - deposit_amount - deposit_mining_txfee, change_address ) );
                        var txid = tapscript.Tx.util.getTxid( papa_swap_funding_tx );
                        var vout = 0;
                        var amnt = deposit_amount;

                        //prepare the revocable address

                        var revocable_scripts = [
                            [
                                2016,
                                "OP_CHECKSEQUENCEVERIFY",
                                "OP_DROP",
                                bobs_pubkey,
                                "OP_CHECKSIG",
                            ],
                            [
                                "OP_SIZE",
                                32,
                                "OP_EQUALVERIFY",
                                "OP_SHA256",
                                papa_swap_hash,
                                "OP_EQUALVERIFY",
                                alices_pubkey,
                                "OP_CHECKSIG",
                            ]
                        ];
                        var revocable_address = hedgehog.makeAddress( revocable_scripts );

                        //actually validate Alice's signature

                        var txfee = 500;
                        var multisig_to_revocable_addy_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( txid, 0, deposit_amount, multisig )],
                            vout: [hedgehog.getVout( deposit_amount - txfee, revocable_address )],
                        });

                        var sighash = tapscript.Signer.taproot.hash( multisig_to_revocable_addy_tx, 0, { extension: multisig_tree[ 0 ] }).hex
                        var sig_is_valid = await nobleSecp256k1.schnorr.verify( sig_for_papa_swap, sighash, alices_pubkey );

                        if ( !sig_is_valid ) {
                            delete hedgehog.state[ chan_id ];
                            return;
                        }

                        //start listening for the cost_of_deposit invoice to be paid
                        var loop = async () => {
                            console.log( 'checking invoice status' );
                            var invoice_status_info = await nwcjs.checkInvoice( nwc_info, invoice, delay_tolerance );
                            if ( invoice_status_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "result_type" in invoice_status_info && invoice_status_info[ "result_type" ] !== "lookup_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "error" in invoice_status_info && invoice_status_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_status_info[ "error" ] )} -- please try again` );
                            if ( invoice_status_info.result.settled_at ) {
                                $( '.income' ).innerText = Number( $( '.income' ).innerText ) + cost_of_deposit;
                                console.log( 'broadcast this:' );
                                console.log( funding_txhex );
                                var txid = await l2generator.pushBTCpmt( funding_txhex );
                                if ( !hedgehog.isValidHex( txid ) ) return alert( `error: ${txid}` );
                                else console.log( `broadcasted tx! ${txid}` );
                                var txfee = 500;
                                $( '.expenses' ).innerText = Number( $( '.expenses' ).innerText ) + txfee;
                                utxo_ids_for_papa_swap.forEach( utxo_id => {
                                    delete l2generator.state.utxos[ utxo_id ];
                                    if ( utxos_created && utxos_created[ 0 ][ "addy" ] === l2generator.state.latest_addy.addy ) {
                                        l2generator.makeUTXO( utxos_created[ 0 ][ "txid" ], utxos_created[ 0 ][ "vout" ], utxos_created[ 0 ][ "amnt" ], utxos_created[ 0 ][ "addy" ], l2generator.state.latest_addy.skey );
                                    }
                                });
                                var msg = JSON.stringify({
                                    type: "cost_of_deposit_paid",
                                    msg: {
                                        funding_txhex,
                                        sigs_and_stuff,
                                    }
                                });
                                var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                                var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                                super_nostr.sendEvent( event, socket );
                                return;
                            }
                            await super_nostr.waitSomeSeconds( loop_delay );
                            return loop();
                        }
                        await loop();
                        //start listening for the deposit_invoice to be paid
                        var loop = async () => {
                            //TODO: if Alice doesn't pay the invoice and it expires, use
                            //sig_for_papa_swap to sweep Bob's funds from the multisig
                            console.log( 'checking invoice status' );
                            var invoice_status_info = await nwcjs.checkInvoice( nwc_info, deposit_invoice, delay_tolerance );
                            if ( invoice_status_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "result_type" in invoice_status_info && invoice_status_info[ "result_type" ] !== "lookup_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                            if ( "error" in invoice_status_info && invoice_status_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_status_info[ "error" ] )} -- please try again` );
                            if ( invoice_status_info.result.settled_at ) {
                               var msg = JSON.stringify({
                                    type: "deposit_complete",
                                    msg: {
                                        chan_id,
                                        preimage: invoice_status_info.result.preimage,
                                    }
                                });
                                var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                                var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                                super_nostr.sendEvent( event, socket );
                                return;
                            }
                            await super_nostr.waitSomeSeconds( loop_delay );
                            return loop();
                        }
                        await loop();
                    }
                    if ( json[ "type" ] === "secret_you_need" ) {
                        var secret = json.msg.secret;
                        sessionStorage[ secret ] = json.msg.thing_needed;
                        setTimeout( () => {sessionStorage.removeItem( secret );}, 5000 );
                    }
                    if ( json[ "type" ] === "initiate_ln_payment" ) {
                        var info_from_alice = json.msg.info_for_bob;
                        var invoice_to_pay = json.msg.invoice_to_pay;
                        var secret_for_responding_to_alice = json.msg.secret;
                        var alices_pubkey = event.pubkey;
                        var invoice_to_pay = await hedgehog.bobReceivesHTLC( info_from_alice, secret_for_responding_to_alice, alices_pubkey, invoice_to_pay );
                        var chan_id = info_from_alice[ "chan_id" ];
                        if ( hedgehog.getInvoiceAmount( invoice_to_pay ) ) {
                            var amnt = null;
                            nwcjs.tryToPayInvoice( nwc_info, invoice_to_pay, amnt );
                            //start listening for the cost_of_deposit invoice to be paid
                            var loop = async () => {
                                console.log( 'checking invoice status' );
                                var delay_tolerance = 10;
                                var invoice_status_info = await nwcjs.checkInvoice( nwc_info, invoice_to_pay, delay_tolerance );
                                if ( invoice_status_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                                if ( "result_type" in invoice_status_info && invoice_status_info[ "result_type" ] !== "lookup_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_status_info )}` );
                                if ( "error" in invoice_status_info && invoice_status_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_status_info[ "error" ] )} -- please try again` );
                                if ( invoice_status_info.result.settled_at ) {
                                    $( '.expenses' ).innerText = Number( $( '.expenses' ).innerText ) + Math.floor( invoice_status_info.result.fees_paid / 1000 );
                                    var pmt_status = await hedgehog.settleIncomingHTLC({ chan_id, preimage: invoice_status_info.result.preimage });
                                    if ( !pmt_status.startsWith( "that went well" ) ) return alert( `something went wrong: ${pmt_status}` );
                                    var msg = JSON.stringify({
                                        type: "payment_succeeded",
                                        msg: {
                                            preimage: invoice_status_info.result.preimage,
                                            chan_id,
                                        }
                                    });
                                    var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                                    var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                                    super_nostr.sendEvent( event, socket );
                                    return;
                                }
                                await super_nostr.waitSomeSeconds( loop_delay );
                                return loop();
                            }
                            await loop();
                        }
                    }
                    if ( json[ "type" ] === "resolve_htlc" ) {
                        var sigs_and_stuff = json.msg.sigs_and_stuff;
                        var skip_pending_check = true;
                        var chan_id = sigs_and_stuff[ "chan_id" ];
                        if ( hedgehog.state[ chan_id ].pending_htlc && hedgehog.state[ chan_id ].pending_htlc.from !== "alice" ) return alert( 'it is unsafe to resolve this htlc' );
                        //TODO: consider more deeply whether I am right to assume it is safe to resolve an htlc
                        //that is from Alice; my reasoning is that her htlcs always pay me more money, so resolving
                        //them is fine; I don't even need to check that she has the right preimage or anything;
                        //because resolving the htlc always results in me receiving more money
                        hedgehog.receive( sigs_and_stuff, skip_pending_check );
                        hedgehog.state[ chan_id ].pending_htlc = {}
                    }
                    if ( json[ "type" ] === "initiate_ln_receive" ) {
                        //TODO: validate that the chan_id exists
                        var chan_id = json.msg.chan_id;
                        var amnt = Number( json.msg.amnt );
                        if ( !amnt || amnt < 0 ) return 'error';
                        //TODO: ensure you have outgoing capacity
                        var delay_tolerance = 10;
                        var invoice_info = await nwcjs.makeInvoice( nwc_info, amnt, desc, delay_tolerance );
                        if ( invoice_info === "timed out" ) return alert( `you encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_info )}` );
                        if ( "result_type" in invoice_info && invoice_info[ "result_type" ] !== "make_invoice" ) return alert( `your wallet encountered an undefined error while processing this deposit request, try again:\n\n${JSON.stringify( invoice_info )}` );
                        if ( "error" in invoice_info && invoice_info[ "error" ] ) return alert( `error processing your deposit request: ${JSON.stringify( invoice_info[ "error" ] )} -- please try again` );
                        var invoice = invoice_info.result.invoice || invoice_info.result.bolt11;
                        var htlc_hash = hedgehog.getInvoicePmthash( invoice );
                        hedgehog.bobSendsHtlc( chan_id, amnt, htlc_hash, invoice, event.pubkey, l2id );
                    }
                }
                await super_nostr.newPermanentConnection( relay, listen, handleEvent );
                operatorStatsLoop();
            }
            var depositorInit = async () => {
                var handled_messages = [];
                var nostr_privkey = super_nostr.getPrivkey();
                var nostr_pubkey = super_nostr.getPubkey( nostr_privkey );
                var depositor_id = super_nostr.getPrivkey().substring( 0, 16 );
                l2generator.state.depositor_data[ depositor_id ] = {
                    nostr_privkey,
                    nostr_pubkey,
                }
                var relay = "wss://nostrue.com";
                var listen = async ( socket ) => {
                    var subId = super_nostr.bytesToHex( crypto.getRandomValues( new Uint8Array( 8 ) ) );
                    var filter  = {}
                    filter.kinds = [ 4 ];
                    filter[ "#p" ] = [ nostr_pubkey ];
                    filter.since = Math.floor( Date.now() / 1000 );
                    var subscription = [ "REQ", subId, filter ];
                    socket.send( JSON.stringify( subscription ) );
                }
                var handleEvent = async message => {
                    var [ type, subId, event ] = JSON.parse( message.data );
                    if ( !event || event === true ) return;
                    if ( handled_messages.includes( event.id ) ) return;
                    handled_messages.push( event.id );
                    if ( event.kind === 4 ) event.content = await super_nostr.decrypt( nostr_privkey, event.pubkey, event.content );
                    var json = JSON.parse( event.content );
                    if ( !json ) return;
                    var recipient = $_GET[ "layer2" ];
                    if ( event.pubkey !== recipient ) return;
                    console.log( json );
                    if ( json[ "type" ] === "l1_balance_query_response" ) {
                        $( '.max_allowed_deposit' ).innerText = `${json.msg.l1_balance}`;
                    }
                    if ( json[ "type" ] === "i_want_to_deposit_response" ) {
                        if ( sessionStorage[ "txid_and_hash_for_confirming_papa_swap" ] ) return;
                        $( '.spam_prevention_cost' ).innerText = json.msg.cost_of_deposit;
                        $( '.spam_prevention_invoice' ).innerText = json.msg.invoice;
                        var deposit_amount = Number( $( '.amount_to_deposit' ).value );
                        $( '.deposit_amount' ).innerText = deposit_amount;
                        $( '.deposit_invoice' ).innerText = json.msg.deposit_invoice;
                        var papa_swap_hash = hedgehog.getInvoicePmthash( json.msg.deposit_invoice );
                        var utxos_for_papa_swap = json.msg.public_utxos_for_papa_swap;
                        var change_address = json.msg.change_address;
                        var bobs_pubkey = json.msg.bobs_pubkey;
                        var alices_pubkey = Object.keys( hedgehog.keypairs )[ 0 ];
                        var alices_privkey = hedgehog.keypairs[ alices_pubkey ][ "privkey" ];
                        var multisig_script = [ alices_pubkey, "OP_CHECKSIGVERIFY", bobs_pubkey, "OP_CHECKSIG" ];
                        var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                        var multisig = hedgehog.makeAddress( [ multisig_script ] );
                        //we are using a papa swap so a transaction needs to go from the multisig to a
                        //revocable address; and a 2 week timelock from the revocable address should give
                        //the funds back to Bob; but if he revokes this path, then of course Alice can
                        //sweep it if Bob tries to use it, because she will have the revocation preimage.
                        var vin = [];
                        var sum = 0;
                        utxos_for_papa_swap.forEach( utxo => {
                            sum = sum + utxo.amnt;
                            vin.push( hedgehog.getVin( utxo.txid, utxo.vout, utxo.amnt, utxo.addy ) );
                        });
                        var papa_swap_funding_tx = tapscript.Tx.create({
                            vin,
                            vout: [hedgehog.getVout( deposit_amount, multisig )],
                        });
                        var deposit_mining_txfee = 500;
                        if ( sum - deposit_amount > 330 ) papa_swap_funding_tx.vout.push( hedgehog.getVout( sum - deposit_amount - deposit_mining_txfee, change_address ) );
                        var txid = tapscript.Tx.util.getTxid( papa_swap_funding_tx );
                        var vout = 0;
                        var amnt = deposit_amount;

                        //prepare the revocable address

                        var revocable_scripts = [
                            [
                                2016,
                                "OP_CHECKSEQUENCEVERIFY",
                                "OP_DROP",
                                bobs_pubkey,
                                "OP_CHECKSIG",
                            ],
                            [
                                "OP_SIZE",
                                32,
                                "OP_EQUALVERIFY",
                                "OP_SHA256",
                                papa_swap_hash,
                                "OP_EQUALVERIFY",
                                alices_pubkey,
                                "OP_CHECKSIG",
                            ]
                        ];
                        var revocable_address = hedgehog.makeAddress( revocable_scripts );

                        //give a sig to Bob sending the money from the multisig to the
                        //revocable address

                        var txfee = 500;
                        var multisig_to_revocable_addy_tx = tapscript.Tx.create({
                            vin: [hedgehog.getVin( txid, 0, deposit_amount, multisig )],
                            vout: [hedgehog.getVout( deposit_amount - txfee, revocable_address )],
                        });

                        var sig = tapscript.Signer.taproot.sign( alices_privkey, multisig_to_revocable_addy_tx, 0, { extension: multisig_tree[ 0 ] }).hex;
                        var secret = json.msg.secret;
                        var msg = JSON.stringify({
                            type: "secret_you_need",
                            msg: {
                                thing_needed: sig,
                                secret,
                            }
                        });
                        var recipient = $_GET[ "layer2" ];
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                        if ( !sessionStorage[ "txid_and_hash_for_confirming_papa_swap" ] ) sessionStorage[ "txid_and_hash_for_confirming_papa_swap" ] = JSON.stringify( [ txid, papa_swap_hash ] );
                        showPage( 'pay_deposit_cost' );
                    }
                    if ( json[ "type" ] === "cost_of_deposit_paid" ) {
                        var [ txid, papa_swap_hash ] = JSON.parse( sessionStorage[ "txid_and_hash_for_confirming_papa_swap" ] );
                        delete sessionStorage[ "txid_and_hash_for_confirming_papa_swap" ];
                        var funding_txhex = json.msg.funding_txhex;
                        var actual_txid = tapscript.Tx.util.getTxid( funding_txhex );
                        var expected_txid = txid;
                        if ( actual_txid !== expected_txid ) return alert( `aborting because Bob tried to scam you: ${actual_txid}, ${expected_txid}` );
                        var sigs_and_stuff = json.msg.sigs_and_stuff;
                        //TODO: validate that the funding_txhex is accepted into the mempool
                        //TODO: validate that the sigs_and_stuff you received uses the
                        //funding_txid and vout as inputs
                        //TODO: once the invoice is paid, store the preimage so you can
                        //penalize Bob if he tries to sweep the funds from the multisig
                        //using the sig_for_papa_swap
                        //TODO: ensure Alice cannot close her channel without the preimage
                        //and that Bob can close the channel *without* the preimage (since
                        //nwc backends don't always provide it)
                        var channel_is_open = await hedgehog.openChannel( null, null, null, null, null, null, sigs_and_stuff );
                        console.log( 'broadcast this:' );
                        console.log( funding_txhex );
                        var txid = await l2generator.pushBTCpmt( funding_txhex );
                        if ( !hedgehog.isValidHex( txid ) ) return alert( `error: ${txid}` );
                        else console.log( `broadcasted tx! ${txid}` );
                        showPage( 'make_deposit' );
                        // alert( `only click ok once this tx confirms, or click ok immediately if you are ok with a 0-conf channel: ${txid}` );
                        //TODO: check if deposit_invoice is paid and give user
                        //an option to paste in the preimage manually in case
                        //the operator doesn't provide it
                        var deposit_invoice = $( '.deposit_invoice' ).innerText;
                    }
                    if ( json[ "type" ] === "deposit_complete" ) {
                        //TODO: validate that the preimage matches the payment hash
                        //and store it so the user can stop Bob in case he tries
                        //to sweep the funds from the multisig
                        console.log( "preimage that means Bob revoked his power to take his money back:" );
                        console.log( json.msg.preimage );
                        depositorLoop();
                        showPage( 'wallet_home' );
                    }
                    if ( json[ "type" ] === "secret_you_need" ) {
                        var secret = json.msg.secret;
                        sessionStorage[ secret ] = json.msg.thing_needed;
                        setTimeout( () => {sessionStorage.removeItem( secret );}, 5000 );
                    }
                    if ( json[ "type" ] === "payment_succeeded" ) {
                        //TODO: validate the channel id and the preimage
                        var chan_id = json.msg.chan_id;
                        var preimage = json.msg.preimage;
                        var sigs_and_stuff = await hedgehog.checkIfOutgoingHTLCIsSettled( chan_id, preimage );
                        // console.log( "send this data to your counterparty:" );
                        // console.log( JSON.stringify( sigs_and_stuff ) );
                        var msg = JSON.stringify({
                            type: "resolve_htlc",
                            msg: {
                                sigs_and_stuff,
                            }
                        });
                        var recipient = $_GET[ "layer2" ];
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                    }
                    if ( json[ "type" ] === "get_revocation_data" ) {
                        //TODO: validate the info sent by Bob
                        //especially that the hash he ends up
                        //sending matches the invoice you're
                        //receiving with
                        var chan_id = json.msg.chan_id;
                        var amnt = json.msg.amnt;
                        var invoice = json.msg.invoice;
                        var secret = json.msg.secret;
                        var invoice_to_receive_with = await hedgehog.aliceReceivesHTLC({chan_id, amnt, secret, invoice});
                        console.log( "have someone pay this:" );
                        console.log( invoice_to_receive_with );
                    }
                    if ( json[ "type" ] === "payment_complete" ) {
                        var chan_id = json.msg.chan_id;
                        var preimage = json.msg.preimage;
                        var sigs_and_stuff = json.msg.sigs_and_stuff;
                        // TODO: uncomment the two lines below
                        // var pmt_status = await hedgehog.settleIncomingHTLC({ chan_id, preimage });
                        // if ( !pmt_status.startsWith( "that went well" ) ) return alert( `something went wrong: ${pmt_status}` );
                        //TODO: consider more deeply whether I am right to assume it is safe to resolve an htlc
                        //that is from Bob; my reasoning is that his htlcs always pay me more money, so resolving
                        //them is fine; I don't even need to check that he has the right preimage or anything;
                        //because resolving the htlc always results in me receiving more money
                        var skip_pending_check = true;
                        hedgehog.receive( sigs_and_stuff, skip_pending_check );
                        hedgehog.state[ chan_id ].pending_htlc = {}
                        //return here to figure out what's wrong with sigs_and_stuff
                        //TODO: as soon as you resolve the htlc get Alice and Bob to both revoke their prior states
                    }
                }
                var socket_id = await super_nostr.newPermanentConnection( relay, listen, handleEvent );
                var socket = super_nostr.sockets[ socket_id ].socket;
                var loop = async () => {
                    if ( socket.readyState !== 1 ) {
                        await super_nostr.waitSomeSeconds( 1 );
                        return loop();
                    }
                    return;
                }
                await loop();
                var msg = JSON.stringify({
                    type: "l1_balance_query",
                    msg: {}
                });
                var recipient = $_GET[ "layer2" ];
                var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                super_nostr.sendEvent( event, socket );
            }
            $( '.submit_deposit_amount' ).onclick = async () => {
                var deposit_amount = Number( $( '.amount_to_deposit' ).value );
                $( '.cost_of_deposit_invoice_loading' ).classList.remove( "hidden" );
                $( '.unhidden_deposit_to_l2' ).classList.add( "hidden" );
                var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                var nostr_privkey = l2generator.state.depositor_data[ depositor_id ][ "nostr_privkey" ];
                var nostr_pubkey = l2generator.state.depositor_data[ depositor_id ][ "nostr_pubkey" ];
                var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                var socket = super_nostr.sockets[ socket_id ].socket;
                //prepare hedgehog info
                var privkey = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var pubkey = nobleSecp256k1.getPublicKey( privkey, true ).substring( 2 );
                var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                hedgehog.keypairs[ pubkey ] = {privkey, preimage};
                var msg = JSON.stringify({
                    type: "i_want_to_deposit",
                    msg: {
                        deposit_amount,
                        pubkey,
                        hash,
                    }
                });
                var recipient = $_GET[ "layer2" ];
                var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                super_nostr.sendEvent( event, socket );
            }
            var depositorLoop = async () => {
                try {
                    var chan_id = Object.keys( hedgehog.state )[ 0 ];
                    var state = hedgehog.state[ chan_id ];
                    var balance = state.balances[ 0 ];
                    $( '.depositor_ln_balance' ).innerText = balance;
                    $( '.send' ).onclick = async () => {
                        var invoice = prompt( `enter an ln invoice` );
                        var chan_id = Object.keys( hedgehog.state )[ 0 ];
                        var htlc_hash = hedgehog.getInvoicePmthash( invoice );
                        var amnt = hedgehog.getInvoiceAmount( invoice );
                        if ( !amnt || !htlc_hash || amnt < 0 ) return alert( `error` );
                        var info_for_bob = await hedgehog.aliceSendsHtlc( chan_id, amnt, htlc_hash, invoice );
                    }
                    $( '.receive' ).onclick = async () => {
                        var amnt = Number( prompt( `enter an amount you want to receive` ) );
                        if ( !amnt ) return;
                        var chan_id = Object.keys( hedgehog.state )[ 0 ];
                        var recipient = $_GET[ "layer2" ];
                        var depositor_id = Object.keys( l2generator.state.depositor_data )[ 0 ];
                        var nostr_privkey = l2generator.state.depositor_data[ depositor_id ].nostr_privkey;
                        var socket_id = Object.keys( super_nostr.sockets )[ 0 ];
                        var socket = super_nostr.sockets[ socket_id ].socket;
                        var msg = JSON.stringify({
                            type: "initiate_ln_receive",
                            msg: {
                                amnt,
                                chan_id,
                            }
                        });
                        var emsg = await super_nostr.encrypt( nostr_privkey, recipient, msg );
                        var event = await super_nostr.prepEvent( nostr_privkey, emsg, 4, [ [ "p", recipient ] ] );
                        super_nostr.sendEvent( event, socket );
                    }
                    $( '.force_close' ).onclick = async () => {
                        var chan_id = Object.keys( hedgehog.state )[ 0 ];
                        var txs = hedgehog.closeChannel( chan_id );
                        var txid = await l2generator.pushBTCpmt( txs[ 0 ] );
                        try {
                            if ( !hedgehog.isValidHex( txid ) ) alert( `error: ${txid}` );
                        } catch ( e ) {}
                        console.log( `force closure initiated: ${txid}` );
                        var blockheight = await l2generator.getBlockheight();
                        var target = blockheight + 5;
                        var loop = async () => {
                            console.log( 'waiting...' );
                            await super_nostr.waitSomeSeconds( 30 );
                            var blockheight = await l2generator.getBlockheight();
                            if ( blockheight < target ) return loop();
                        }
                        await loop();
                        var txid = await l2generator.pushBTCpmt( txs[ 1 ] );
                        if ( !hedgehog.isValidHex( txid ) ) return alert( `error: ${txid}` );
                        console.log( `force closure finalized: ${txid}` );
                    }
                } catch ( e ) {}
                await super_nostr.waitSomeSeconds( 1 );
                depositorLoop();
            }
        </script>
    </body>
</html>
